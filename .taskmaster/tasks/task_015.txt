# Task ID: 15
# Title: Integrate Task Scheduler
# Status: done
# Dependencies: 2
# Priority: medium
# Description: Integrate a Task Scheduler component into the bot architecture. This component is responsible for scheduling and triggering events based on time limits, specifically for claim timeouts (`claim_timeout`) and submission timeouts (`writing_timeout`, `drawing_timeout`) as defined in the season rules. It should be reliable and ideally persist scheduled tasks across bot restarts.
# Details:


# Test Strategy:
Develop comprehensive tests focusing on the core scheduler component's functionality, persistence, and recovery mechanisms. Utilize a test database for integration tests involving persistence, avoiding mocking the database layer. Ensure tests verify job scheduling, execution, cancellation, and persistence using real database operations. The scheduler component tests should remain platform-agnostic, without dependencies on Discord or other bot-specific integrations.

# Subtasks:
## 1. Select or implement scheduler [done]
### Dependencies: None
### Description: Research, evaluate, and select an appropriate scheduling system or implement a custom solution for the bot.
### Details:
Evaluate scheduling software options based on security features (data encryption, secure hosting), scalability to handle increasing user traffic, and comprehensive customer support/training resources. Consider factors like A/B testing capabilities and proactive assistance features. If implementing custom, ensure it can handle time-based triggers with proper UTC time format (HHMM).
<info added on 2025-05-22T15:03:15.516Z>
Decision: The existing `node-schedule` library will be used as the scheduler for the bot.

Rationale:
- `node-schedule` is already integrated and actively used in `src/services/SeasonService.ts` for scheduling season activation based on `openDuration`, ensuring consistency and reducing the need for new dependencies.
- The current implementation leverages a `scheduledActivationJobs` Map for managing scheduled jobs, which can be adapted for broader scheduling needs.
- `node-schedule` supports both cron-style and date-based scheduling, offering flexibility for both recurring and one-time jobs[1][2][3].
- Compared to alternatives, `node-schedule` balances simplicity and flexibility, making it suitable for time-based triggers and adaptable for more frequent, turn-based timeouts (e.g., claim and submission windows)[3].

Next Steps:
- Enhance integration with the bot lifecycle (see Subtask 15.2).
- Implement database persistence for scheduled jobs, as the current Map-based approach is in-memory only (see Subtask 15.3).
- Adapt the scheduling logic to support more granular, frequent timeouts as required by the application's turn-based features.
</info added on 2025-05-22T15:03:15.516Z>

## 2. Integrate with bot lifecycle [done]
### Dependencies: 15.1
### Description: Connect the scheduler with the bot's operational lifecycle to manage starting, stopping, and other state transitions.
### Details:
Implement mechanisms to start/stop bot instances based on scheduled events. Ensure proper handling of bot lifecycle states including initialization, execution, and termination. Configure the system to prevent scheduling conflicts where execution time exceeds the interval between scheduled runs. Implement proper tagging for resources to denote shutdown/startup times.

## 3. Implement persistence for scheduled tasks [done]
### Dependencies: 15.1, 15.2
### Description: Develop a storage solution to maintain scheduled task information across system restarts or failures.
### Details:
Create a database schema to store scheduling information including task details, execution history, and state. Implement queue-based triggers for dependent processes to ensure sequential execution when needed. Design recovery mechanisms for handling failures during scheduled executions, including appropriate retry logic with waiting periods before retrying failed processes.
<info added on 2025-05-22T18:01:27.967Z>
Implementation of persistence for scheduled tasks will proceed as follows:

- Introduce a new Prisma model `ScheduledJob` to persist job metadata. The schema will include fields for unique job identifiers, job type, execution time, serialized job data, status, timestamps for creation, updates, and execution, and failure reasons. This design ensures each scheduled job is uniquely tracked and auditable, supporting both one-off and recurring jobs[1][3][5].

- Extend `SchedulerService` with persistence methods:
  - `persistJob()` will save job details to the database whenever a job is scheduled.
  - `loadPersistedJobs()` will be called on bot startup to restore and reschedule jobs from the database, ensuring jobs survive restarts.
  - `removePersistedJob()` will delete or update job records when jobs are completed or cancelled.

- Modify `scheduleJob()` and `cancelJob()` to integrate with the persistence layer, ensuring all job lifecycle events are reflected in the database.

- Implement a recovery mechanism: On startup, `loadPersistedJobs()` will check for jobs whose scheduled execution time has passed while the bot was offline. These jobs will be marked as missed or failed, and retry logic will be applied according to the job's configuration, with appropriate waiting periods before retry attempts[5].

- The database schema will support querying by job status, type, and execution history, enabling efficient recovery, monitoring, and audit trails[5].

- The persistence layer will be designed to support both ad hoc and recurring jobs, with fields for recurrence and scheduling metadata as needed[1][3].

This approach ensures scheduled jobs are durable, recoverable, and auditable, providing a robust foundation for reliable task scheduling across system restarts and failures.
</info added on 2025-05-22T18:01:27.967Z>
<info added on 2025-05-22T18:15:02.384Z>
<info added on 2025-05-22T18:35:42Z>

Persistence for scheduled tasks has been fully implemented, providing robust durability and recovery for all scheduled jobs:

**Database Schema:**
- Introduced a `ScheduledJob` model in the Prisma schema with fields for id, jobId, fireDate, jobType, jobData, status, createdAt, updatedAt, executedAt, and failureReason.
- Applied database migration and added indexes on status, jobType, fireDate, and jobId for efficient querying and performance.
- Schema supports both one-off and recurring jobs, and enables audit trails and execution history tracking[1][3][5].

**SchedulerService Enhancements:**
- Integrated PrismaClient for database operations.
- Made `scheduleJob()` and `cancelJob()` asynchronous to persist changes.
- Implemented persistence methods:
  - `persistJob()` to save job details when scheduled.
  - `markJobExecuted()` and `markJobFailed()` to update job status and record execution outcomes.
  - `removePersistedJob()` to clean up completed or cancelled jobs.
- Added `loadPersistedJobs()` for startup recovery:
  - Restores jobs from the database on bot startup.
  - Marks jobs with missed execution times as FAILED and applies retry logic if configured.
  - Reschedules future jobs with appropriate callbacks.

**Integration:**
- Updated bot startup to inject PrismaClient into SchedulerService and invoke `loadPersistedJobs()`.
- Refactored SeasonService and related modules to use async scheduling methods.
- Maintained backward compatibility with existing scheduling features.

**Testing:**
- Developed a comprehensive test suite covering job scheduling, persistence, duplicate prevention, past date validation, cancellation, restoration, missed job handling, and execution tracking.
- All tests pass, confirming reliability and correctness.

**Key Features:**
- Scheduled jobs persist across bot restarts and system failures.
- Missed jobs are detected and marked as failed, with retry logic as needed.
- Full audit trail and execution history for all jobs.
- Robust error handling and cleanup.
- Efficient querying and monitoring of scheduled jobs.

This implementation ensures a reliable, auditable, and recoverable task scheduling system that meets the requirements for persistent, distributed job management[1][3][5].
</info added on 2025-05-22T18:35:42Z>
</info added on 2025-05-22T18:15:02.384Z>

## 4. Write tests for scheduling and triggering [done]
### Dependencies: 15.1, 15.2, 15.3
### Description: Develop comprehensive test cases to verify the reliability and accuracy of the scheduling system.
### Details:
Create unit tests for individual scheduling components. Develop integration tests to verify proper interaction between the scheduler component and the persistence layer. Implement stress tests to ensure the system handles concurrent scheduling without resource overload. Test edge cases such as system failures during execution, timezone handling, and daylight saving time transitions. 

Align testing with project guidelines:
- Use a dedicated test database for integration tests involving persistence, avoiding mocking the database.
- Ensure tests focus on the core scheduler component, keeping it platform-agnostic (no Discord dependencies).
- Verify job scheduling, execution, cancellation, persistence, and recovery mechanisms using real database operations against the test database.
- Test the scheduler's interaction with the database to ensure data integrity and correct state transitions for scheduled jobs.
<info added on 2025-05-22T19:38:14.855Z>
Enhance SchedulerService tests to fully align with the updated test strategy:

- Remove all mocking of node-schedule in integration tests. Use real timers and actual scheduling logic to verify that jobs are scheduled, triggered, and executed as expected in real-world scenarios.
- Add stress tests that schedule, execute, and cancel a large number of jobs concurrently. Measure system stability, resource usage, and ensure no race conditions or deadlocks occur during high concurrency.
- Implement comprehensive timezone and edge case tests. Verify correct job execution across multiple timezones, including transitions into and out of daylight saving time, and test for edge cases such as leap years and ambiguous/nonexistent times.
- Expand job restoration and recovery tests. Simulate system restarts, database failures, and partial job state corruption. Ensure that jobs are correctly restored, missed jobs are handled according to policy, and no duplicate executions occur.
- Add database transaction and rollback tests. Intentionally trigger failures during job scheduling, execution, and cancellation to verify that all database operations are atomic and that the system properly rolls back on errors, maintaining data integrity.
- Test job cleanup and memory management. After job completion or cancellation, verify that all job references are removed from memory and the database, and that no resource leaks occur.

All tests should use a real test database for persistence verification, focusing on the core scheduler component and remaining platform-agnostic (no Discord dependencies). Ensure tests cover job scheduling, execution, cancellation, persistence, recovery, and cleanup, with a focus on data integrity and correct state transitions.
</info added on 2025-05-22T19:38:14.855Z>
<info added on 2025-05-22T19:41:53.095Z>
âœ… COMPLETED: Enhanced SchedulerService Tests

Successfully implemented a comprehensive test suite fully aligned with project guidelines and best practices for task scheduling systems.

Key Improvements Made:
- Removed all mocking of node-schedule in integration tests; tests now use real timers and actual scheduling logic to verify job scheduling, triggering, and execution in real-world scenarios.
- Added robust stress tests for concurrent job scheduling, execution, and cancellation, ensuring system stability and no race conditions or deadlocks under high concurrency.
- Enhanced error handling tests by simulating real database errors (e.g., invalid connection strings) and invalid callback scenarios, verifying graceful error management and proper rollback.
- Implemented comprehensive recovery testing, including multiple job restoration scenarios, missed job handling, and prevention of duplicate executions after simulated system restarts or partial job state corruption.
- Verified atomicity of database operations and proper rollback on errors, maintaining data integrity throughout job scheduling, execution, and cancellation.
- Added memory management and cleanup tests to ensure job references are removed from memory and the database after completion or cancellation, preventing resource leaks.
- Developed extensive timezone and edge case tests, covering execution across multiple timezones, daylight saving time transitions, leap years, ambiguous/nonexistent times, and far future dates.
- Included job data serialization tests for complex data structures and null/undefined cases, ensuring robust handling and persistence.

Test Results:
- All 22 tests passing
- Real database integration (no Prisma mocking)
- Platform-agnostic (no Discord dependencies)
- Comprehensive coverage of core scheduling functionality, including job lifecycle, error scenarios, edge cases, and concurrent operations

Technical Implementation:
- Used a dedicated real test database for all integration and persistence verification
- Simulated database errors and tested rollback mechanisms
- Verified job lifecycle from scheduling through execution to cleanup
- Ensured persistence and recovery mechanisms work as intended
- Maintained platform independence and focused on the core scheduler component

The SchedulerService test suite now provides robust, reliable verification of all core scheduling features, error handling, and data integrity, meeting all outlined requirements and project standards.
</info added on 2025-05-22T19:41:53.095Z>

