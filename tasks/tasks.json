{
  "tasks": [
    {
      "id": 1,
      "title": "Define Database Schema (Prisma/PostgreSQL)",
      "description": "Define the database schema using Prisma for PostgreSQL, including tables for Seasons, Games, Players (within a season context), Turns, and configuration settings. Establish relationships between these entities to support the season structure (Season has Players, Season has Games, Game is in Season, Game has Turns, Turn belongs to Player). Include necessary fields for states, content, timestamps, and configurable parameters.",
      "details": "",
      "testStrategy": "Verify the Prisma schema syntax is correct. Run Prisma migrations to create the database tables and ensure they match the defined models and relationships. Manually inspect the database structure.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define Season and Player Models",
          "description": "Create Prisma schema models for Season and Player entities with appropriate fields and relationships",
          "dependencies": [],
          "details": "Define the Season model with fields for name, start/end dates, status, and configuration settings. Create the Player model with fields for name, email, status, and season association. Establish a many-to-many relationship between Seasons and Players using a join table.\n<info added on 2025-05-11T14:59:40.425Z>\n<update timestamp=\"2025-05-11T14:59:26Z\">\nThe Prisma schema models for Season and Player will be defined as follows:\n\n**Player Model**\n- **id**: String, default cuid(), @id (unique identifier)\n- **discordUserId**: String, @unique (links to Discord user ID)\n- **name**: String (stores Discord username)\n- **email**: String? (optional, as per PRD)\n- **status**: String (e.g., \"NOT_BANNED\", \"BANNED\" based on PRD Player States)\n- **createdAt**: DateTime, @default(now())\n- **updatedAt**: DateTime, @updatedAt\n- **seasons**: PlayersOnSeasons[] (for M2M with Season)\n- **createdSeasons**: Season[] @relation(\"CreatedSeasons\") (tracks seasons created by this player)\n- **turns**: Turn[] (for 12M with Turn, to be defined later)\n\n**Season Model**\n- **id**: String, default cuid(), @id\n- **name**: String, @unique (PRD implies unique names for seasons)\n- **status**: String (e.g., \"SETUP\", \"PENDING\", \"ACTIVE\", \"COMPLETED\", \"TERMINATED\" - from PRD Game States, adapted for Season)\n- **openDuration**: String? (e.g., \"7d\", from PRD Season Rules)\n- **minPlayers**: Int?, default 2 (from PRD Season Rules)\n- **maxPlayers**: Int? (from PRD Season Rules)\n- **turnPattern**: String, default \"writing,drawing\" (from PRD Season Rules)\n- **claimTimeout**: String, default \"1d\" (from PRD Season Rules)\n- **writingTimeout**: String, default \"1d\" (from PRD Season Rules)\n- **writingWarning**: String, default \"1m\" (from PRD Season Rules)\n- **drawingTimeout**: String, default \"1d\" (from PRD Season Rules)\n- **drawingWarning**: String, default \"10m\" (from PRD Season Rules)\n- **createdAt**: DateTime, @default(now())\n- **updatedAt**: DateTime, @updatedAt\n- **games**: Game[] (for 12M with Game, to be defined later)\n- **players**: PlayersOnSeasons[] (for M2M with Player)\n- **creatorId**: String (Foreign key to Player who created the season)\n- **creator**: Player @relation(\"CreatedSeasons\", fields: [creatorId], references: [id])\n\n**Join Table for Player-Season M2M (PlayersOnSeasons)**\n- **player**: Player @relation(fields: [playerId], references: [id])\n- **playerId**: String\n- **season**: Season @relation(fields: [seasonId], references: [id])\n- **seasonId**: String\n- **assignedAt**: DateTime, @default(now())\n- **@@id([playerId, seasonId])** (Composite primary key)\n\nThis structure addresses the requirements for Season and Player models and their M2M relationship. Configuration settings are included as fields in the Season model as per PRD Season Rules. Fields for Game and Turn relationships are noted as placeholders for subsequent subtasks. Using String for IDs with cuid() as Prisma/PostgreSQL doesn't have a native UUID type that auto-increments in the same way as uuid() with uuid_generate_v4() without extensions, and cuid() is a good Prisma-recommended default. Player status from PRD: \"NOT_BANNED\", \"BANNED\". Season status derived from PRD \"Game States\": \"SETUP\", \"PENDING\", \"ACTIVE\", \"COMPLETED\", \"TERMINATED\". The PRD mentions \"name, email, status, and season association\" for Player. discordUserId is added for a reliable link to the Discord entity. name can store the Discord username. The PRD mentions \"name, start/end dates, status, and configuration settings\" for Season. Start/end dates are covered by createdAt/updatedAt and game/turn progression. Configuration settings from PRD \"Season Rules\" are added as fields directly to the Season model. The creator relation links a Season back to the Player who initiated it.\n</update>\n</info added on 2025-05-11T14:59:40.425Z>",
          "status": "done",
          "testStrategy": "Validate schema using Prisma CLI and ensure relationships are properly defined with correct field types and constraints"
        },
        {
          "id": 2,
          "title": "Define Game and Turn Models",
          "description": "Create Prisma schema models for Game and Turn entities with appropriate fields and relationships",
          "dependencies": [
            1
          ],
          "details": "Define the Game model with fields for title, status, start/end times, and season association. Create the Turn model with fields for content, status, timestamps, and associations to both Game and Player. Establish one-to-many relationships between Games and Turns.\n<info added on 2025-05-11T15:01:43.429Z>\nDefine the Game model with fields for id (String, default cuid(), @id), status (String, e.g., 'SETUP', 'ACTIVE', 'COMPLETED', 'TERMINATED'), createdAt (DateTime, @default(now())), updatedAt (DateTime, @updatedAt), completedAt (DateTime?), seasonId (String), season (Season @relation(fields: [seasonId], references: [id])), turns (Turn[]), initiatingPlayerId (String), and initiatingPlayer (Player @relation('InitiatedGames', fields: [initiatingPlayerId], references: [id])). The Game model establishes a one-to-many relationship with Turn via the turns field. The Turn model includes id (String, default cuid(), @id), gameId (String), game (Game @relation(fields: [gameId], references: [id])), playerId (String?), player (Player? @relation(fields: [playerId], references: [id])), turnNumber (Int), type (String, e.g., 'WRITING', 'DRAWING'), status (String, e.g., 'AVAILABLE', 'OFFERED', 'PENDING', 'COMPLETED', 'SKIPPED'), textContent (String?), imageUrl (String?), createdAt (DateTime, @default(now())), updatedAt (DateTime, @updatedAt), offeredAt (DateTime?), claimedAt (DateTime?), completedAt (DateTime?), skippedAt (DateTime?), previousTurnId (String? @unique), previousTurn (Turn? @relation('TurnChain', fields: [previousTurnId], references: [id], onDelete: NoAction, onUpdate: NoAction)), and nextTurn (Turn? @relation('TurnChain')). The Turn model supports a self-relation for chaining turns and links to both Game and Player. Update the Season model to include games Game[] and the Player model to include initiatedGames Game[] @relation('InitiatedGames') and turns Turn[] to reflect these relationships. Ensure all fields and relations are type-safe and support the required business logic for game and turn states.\n</info added on 2025-05-11T15:01:43.429Z>",
          "status": "done",
          "testStrategy": "Verify schema integrity with Prisma CLI and test relationship queries to ensure proper data access patterns"
        },
        {
          "id": 3,
          "title": "Implement Configuration Settings Model",
          "description": "Create a dedicated model for storing configurable parameters that affect season and game behavior",
          "dependencies": [
            1,
            2
          ],
          "details": "Define a Configuration model with fields for parameter names, values, types, and descriptions. Create relationships to link configurations to specific Seasons or make them global. Include default values and validation rules.\n<info added on 2025-05-11T17:09:57.471Z>\nDefine a dedicated `SeasonConfig` model to centralize all season and game configuration parameters. The model will include fields for parameter names, values, types, and descriptions, with default values and validation rules as specified in the PRD. Key fields include `turnPattern`, `claimTimeout`, `writingTimeout`, `writingWarning`, `drawingTimeout`, `drawingWarning`, `openDuration`, `minPlayers`, `maxPlayers`, and timestamps. The model supports both global fallback defaults and guild-specific overrides via the `isGuildDefaultFor` field. Each `Season` will reference a `SeasonConfig` instance through a required one-to-one relationship, ensuring that configuration is decoupled from the `Season` model and can be managed independently. This approach allows for flexible configuration management, including the ability to initialize new seasons with guild defaults or custom configurations, and supports future extensibility for additional parameters.\n</info added on 2025-05-11T17:09:57.471Z>",
          "status": "done",
          "testStrategy": "Test configuration retrieval and application to ensure parameters correctly influence system behavior"
        },
        {
          "id": 4,
          "title": "Establish Cross-Entity Relationships",
          "description": "Define and implement all relationships between models to support the required data structure",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implement relations between Season-Game (one-to-many), Season-Player (many-to-many), Game-Turn (one-to-many), and Turn-Player (many-to-one). Use Prisma's @relation attribute with appropriate fields and references directives. Add indexes for performance optimization.\n<info added on 2025-05-11T17:11:06.898Z>\nAll required cross-entity relationships have been reviewed and confirmed as implemented in the Prisma schema. The following relationships are correctly defined using Prisma's @relation attribute with appropriate fields and references directives: Season-Game (one-to-many), Season-Player (many-to-many via a join table), Game-Turn (one-to-many), and Turn-Player (many-to-one). Additional explicit relationships, including Player to Season (creator), Player to Game (initiator), Season to SeasonConfig (one-to-one), and Turn to Turn (self-relation for chaining), are also in place. All necessary fields and references are configured as per the design from previous subtasks. Indexes for performance optimization will be addressed in the next subtask (1.5). The test strategy for verifying relationship traversal will be handled during integration testing or via Prisma Client tests at a later stage. No further schema changes are required for this subtask.\n</info added on 2025-05-11T17:11:06.898Z>",
          "status": "done",
          "testStrategy": "Create test data and verify that all relationships can be traversed in both directions with Prisma Client queries"
        },
        {
          "id": 5,
          "title": "Add Database Constraints and Indexes",
          "description": "Implement necessary constraints and indexes to maintain data integrity and query performance",
          "dependencies": [
            4
          ],
          "details": "Add unique constraints for Season names, Player emails within seasons, and Game titles within seasons. Create indexes for frequently queried fields like status, timestamps, and foreign keys. Implement cascading deletes where appropriate to maintain referential integrity.\n<info added on 2025-05-11T17:11:57.566Z>\nAdd unique constraints for Season names, Player emails within seasons, and Game titles within seasons. Create indexes for frequently queried fields like status, timestamps, and foreign keys. Implement cascading deletes where appropriate to maintain referential integrity.\n\n<update timestamp=\"2025-05-11T17:11:49Z\">\n**Unique Constraints Review:**\n- Existing unique constraints on `Player.discordUserId`, `Season.name`, `SeasonConfig.isGuildDefaultFor`, `Season.configId`, and `Turn.previousTurnId` are appropriate and require no changes. No unique constraint is needed for Game titles at this time, as games do not currently have titles.\n\n**Indexes Plan:**\n- **Player:** Add `@@index([status])` for efficient status-based queries.\n- **Season:** Add `@@index([status])` and `@@index([creatorId])` to optimize status and creator lookups.\n- **PlayersOnSeasons:** Add `@@index([playerId])` and `@@index([seasonId])` to complement the composite primary key and speed up joins.\n- **Game:** Add `@@index([status])`, `@@index([seasonId])`, and `@@index([initiatingPlayerId])` for status, season, and initiator filtering.\n- **Turn:** Add `@@index([status])`, `@@index([type])`, `@@index([gameId])`, `@@index([playerId])`, and `@@index([createdAt])` to support status, type, game, player, and chronological queries.\n\n**Cascading Deletes Plan:**\n- **Season.config:** Set `onDelete: Cascade` to delete config when season is deleted.\n- **PlayersOnSeasons.player:** Set `onDelete: Cascade` to remove participations when a player is deleted.\n- **PlayersOnSeasons.season:** Set `onDelete: Cascade` to remove participations when a season is deleted.\n- **Game.season:** Set `onDelete: Cascade` to delete games when a season is deleted.\n- **Game.initiatingPlayer:** Set `onDelete: Restrict` to prevent player deletion if they initiated games.\n- **Turn.game:** Set `onDelete: Cascade` to delete turns when a game is deleted.\n- **Turn.player:** Set `onDelete: SetNull` to nullify player references in turns if a player is deleted (playerId is optional).\n- **Season.creator:** Set `onDelete: Restrict` to prevent player deletion if they created seasons.\n- **Turn.previousTurn:** Leave as `onDelete: NoAction` for self-referential chains.\n</update>\n</info added on 2025-05-11T17:11:57.566Z>",
          "status": "done",
          "testStrategy": "Test constraint enforcement by attempting to violate constraints and measure query performance with and without indexes"
        }
      ]
    },
    {
      "id": 2,
      "title": "Setup Basic Discord Bot Infrastructure",
      "description": "Set up the basic Discord bot infrastructure using Discord.js. This includes initializing the client, connecting to Discord, setting up event listeners (e.g., 'ready', 'interactionCreate', 'messageCreate' for DMs), and integrating a framework for handling slash commands.",
      "details": "",
      "testStrategy": "Run the bot application. Verify it connects successfully to Discord and logs in. Confirm that basic event listeners are active.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Configuration Loading",
      "description": "Implement the logic to load configuration settings from `config/config.json` (specifically for the guild ID) and potentially a separate file like `.taskmasterconfig` for default season parameters as mentioned in the PRD. Ensure configuration is accessible throughout the application.",
      "details": "",
      "testStrategy": "Create sample config files. Run the application and verify that the configuration values are loaded correctly and are accessible in relevant parts of the code.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Development Commands (Register/Clear Guild Commands)",
      "description": "Implement the development commands `pnpm run commands:register:guild` and `pnpm run commands:clear:guild`. These commands should use the Discord.js API to register and clear slash commands specifically for the guild ID specified in `config/config.json` as required for development workflow.",
      "details": "",
      "testStrategy": "Run `pnpm run commands:register:guild` and verify commands appear in the target guild. Run `pnpm run commands:clear:guild` and verify commands are removed from the target guild.",
      "priority": "medium",
      "dependencies": [
        2,
        3
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Establish Core Service and Pure Logic Structure",
      "description": "Create the initial structure for the service layer (`src/services/`) and pure game logic functions (`src/game/`). Define placeholder classes/files for `SeasonService`, `GameService`, `PlayerService`, `TurnService` and basic function signatures based on the required operations (create season, add player, claim turn, submit turn, etc.).",
      "details": "",
      "testStrategy": "Verify that the required directories and files are created with basic class/function definitions. Ensure they can be imported without errors.",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Core Directories",
          "description": "Establish the main directory structure to house service classes and pure game logic functions. [Updated: 5/11/2025] [Updated: 5/11/2025]",
          "dependencies": [],
          "details": "Create directories such as '/services' and '/game_logic' (or similar naming conventions) at the appropriate level within the project structure.\n<info added on 2025-05-11T22:08:00.047Z>\nCreate the following directories at the root of the 'src' folder to organize core project components: 'src/services' for all service classes and related utilities, and 'src/game' for pure game logic functions, core game systems, and related modules. This structure supports modularity, clear separation of concerns, and easy navigation for future development and maintenance. Ensure directory names are consistent and do not use spaces or special characters. This foundational setup will facilitate the creation of service class placeholder files and further logic implementation in subsequent subtasks.\n</info added on 2025-05-11T22:08:00.047Z>\n<info added on 2025-05-11T22:08:46.583Z>\nDirectory structure has been established as follows: 'src/services' already existed and was confirmed to be in place; 'src/game' was newly created to house all pure game logic functions, core game systems, and related modules. This structure supports modularity, clear separation of concerns, and easy navigation for future development and maintenance. Directory names are consistent and do not use spaces or special characters. This foundational setup will facilitate the creation of service class placeholder files and further logic implementation in subsequent subtasks.\n<info added on 2025-05-11T22:08:00.047Z>\nThe 'src/services' directory is intended for all service classes and related utilities, while 'src/game' is dedicated to pure game logic, core systems, and modular components. This separation ensures that service-related code and game logic are kept distinct, supporting maintainability and scalability as the project grows. Future subtasks will focus on populating these directories with placeholder files and implementing core logic.\n</info added on 2025-05-11T22:08:46.583Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Create Service Class Placeholder Files",
          "description": "Generate empty or minimal placeholder files for anticipated service classes within the designated service directory.",
          "dependencies": [
            1
          ],
          "details": "Based on initial project design, identify potential service classes (e.g., 'UserService', 'GameService') and create corresponding files (e.g., 'user_service.py', 'game_service.py') inside the '/services' directory.\n<info added on 2025-05-11T22:09:09.340Z>\nBased on initial project design, identify potential service classes and create corresponding files inside the '/services' directory. For this subtask, create the following minimal TypeScript class files in the 'src/services' directory: 'SeasonService.ts' with an empty or minimal class definition for SeasonService, 'GameService.ts' for GameService, 'PlayerService.ts' for PlayerService, and 'TurnService.ts' for TurnService. Each file should export a class with the same name as the file, ready for future implementation of business logic and data handling. These service classes will serve as foundational components for encapsulating core application logic and API interactions, following TypeScript best practices for class structure and modularity[1][5].\n\n<update timestamp=\"2025-05-11T22:09:04Z\">\nThe following files should be created as minimal class placeholders:\n- src/services/SeasonService.ts: export class SeasonService {}\n- src/services/GameService.ts: export class GameService {}\n- src/services/PlayerService.ts: export class PlayerService {}\n- src/services/TurnService.ts: export class TurnService {}\n</update>\n</info added on 2025-05-11T22:09:09.340Z>\n<info added on 2025-05-11T22:10:08.793Z>\nBased on initial project design, placeholder files for core service classes have been created in the 'src/services' directory. Each file contains a minimal TypeScript class definition, following best practices for modularity and future extensibility. The following files are now in place and ready for further implementation:\n- src/services/SeasonService.ts: export class SeasonService {}\n- src/services/GameService.ts: export class GameService {}\n- src/services/PlayerService.ts: export class PlayerService {}\n- src/services/TurnService.ts: export class TurnService {}\n\nThese classes serve as foundational components for encapsulating core application logic and API interactions, and are prepared for the next phase of business logic and data handling implementation[1][5].\n\n<info added on 2025-05-11T22:09:09.340Z>\nThe following files should be created as minimal class placeholders:\n- src/services/SeasonService.ts: export class SeasonService {}\n- src/services/GameService.ts: export class GameService {}\n- src/services/PlayerService.ts: export class PlayerService {}\n- src/services/TurnService.ts: export class TurnService {}\n</info added on 2025-05-11T22:09:09.340Z>\n</info added on 2025-05-11T22:10:08.793Z>",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Create Game Logic Placeholder Files",
          "description": "Generate empty or minimal placeholder files for anticipated pure game logic functions within the designated game logic directory.",
          "dependencies": [
            1
          ],
          "details": "Identify potential modules for pure game logic functions (e.g., 'game_rules', 'math_utils') and create corresponding files (e.g., 'game_rules.py', 'math_utils.py') inside the '/game_logic' directory.\n<info added on 2025-05-11T22:10:34.398Z>\nIdentify and create placeholder files for core game logic modules in the '/src/game' directory. Each file should contain minimal function stubs for anticipated logic, ensuring clear separation of concerns and easy future expansion. Specifically, create the following files and functions:\n\n- **seasonLogic.ts**: Contains `createSeasonPlaceholder()` to initialize or reset season-related game state.\n- **playerLogic.ts**: Contains `addPlayerPlaceholder()` to handle player addition logic.\n- **turnLogic.ts**: Contains `claimTurnPlaceholder()`, `submitTurnPlaceholder()`, `offerTurnPlaceholder()`, `skipTurnPlaceholder()`, and `dismissOfferPlaceholder()` to manage turn lifecycle and player actions.\n- **gameLogic.ts**: Contains `activateSeasonPlaceholder()`, `nextPlayerLogicPlaceholder()`, `checkGameCompletionPlaceholder()`, and `checkSeasonCompletionPlaceholder()` to orchestrate game flow, player rotation, and completion checks.\n\nThese files should be placed in the '/src/game' directory and serve as the foundation for implementing pure game logic, following best practices for modularity and maintainability.\n</info added on 2025-05-11T22:10:34.398Z>\n<info added on 2025-05-11T22:12:11.002Z>\nIdentify potential modules for pure game logic functions (e.g., 'game_rules', 'math_utils') and create corresponding files (e.g., 'game_rules.py', 'math_utils.py') inside the '/game_logic' directory.\n<info added on 2025-05-11T22:10:34.398Z>\nIdentify and create placeholder files for core game logic modules in the '/src/game' directory. Each file should contain minimal function stubs for anticipated logic, ensuring clear separation of concerns and easy future expansion. Specifically, create the following files and functions:\n\n- **seasonLogic.ts**: Contains `createSeasonPlaceholder()` to initialize or reset season-related game state.\n- **playerLogic.ts**: Contains `addPlayerPlaceholder()` to handle player addition logic.\n- **turnLogic.ts**: Contains `claimTurnPlaceholder()`, `submitTurnPlaceholder()`, `offerTurnPlaceholder()`, `skipTurnPlaceholder()`, and `dismissOfferPlaceholder()` to manage turn lifecycle and player actions.\n- **gameLogic.ts**: Contains `activateSeasonPlaceholder()`, `nextPlayerLogicPlaceholder()`, `checkGameCompletionPlaceholder()`, and `checkSeasonCompletionPlaceholder()` to orchestrate game flow, player rotation, and completion checks.\n\nThese files should be placed in the '/src/game' directory and serve as the foundation for implementing pure game logic, following best practices for modularity and maintainability.\n<info added on 2025-05-11T22:10:34.398Z>\n<info added on 2025-05-11T22:12:04.000Z>\nPlaceholder files and functions have been created in `src/game/` as specified. Each file contains minimal stubs for the listed functions, providing a clear structure for future logic implementation. This modular approach supports separation of concerns, making it easier to expand and maintain the game logic as development progresses. The structure aligns with best practices for organizing pure logic modules, ensuring that each file and function is focused on a single responsibility and can be independently tested and updated.\n</info added on 2025-05-11T22:12:11.002Z>",
          "status": "done"
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement '/new season' Command",
      "description": "Implement the `/new season` slash command handler in `src/commands/chat`. This handler should parse command options, call the `SeasonService` to create a new season entry in the database, generate a unique season ID, and send a Direct Message to the season creator requesting their initial turn.",
      "details": "",
      "testStrategy": "Use the `/new season` command in a channel and via DM. Verify a new season is created in the database with the correct initial state and parameters. Confirm the season creator receives a DM requesting their first turn.",
      "priority": "medium",
      "dependencies": [
        2,
        5
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Command Parsing Logic",
          "description": "Create a command handler that parses user input and extracts command arguments",
          "dependencies": [],
          "details": "Develop a command parser that identifies command prefixes, separates arguments, and validates input format. Use Discord.js or Discord.py command handling frameworks to register commands and process options. Implement type conversion for arguments as needed.\n<info added on 2025-05-12T22:49:41.390Z>\n<update><timestamp>2025-05-12T22:49:35Z</timestamp><content>To implement the command parsing logic for the '/new season' command, begin by locating or creating the appropriate command file within the `src/commands/chat/` directory, such as `new-season.ts`. Use the Discord.js `SlashCommandBuilder` to define the command, specifying all required and optional options as outlined in the PRD and schema definition. These options include the season name (required, string), open duration (optional, string), min and max players (optional, integers), turn pattern (optional, string), and various timeout options (optional, strings). Implement the `execute` async function within the module, which will receive the `ChatInputCommandInteraction` object. Inside this function, extract each option using the appropriate `interaction.options` methods (e.g., `getString`, `getInteger`). Perform basic validation on the extracted values, such as checking for required fields and ensuring string formats for durations and timeouts are valid. Structure the validated options into an object suitable for passing to the `SeasonService` (to be implemented in the next subtask). Add a placeholder comment for the service call and for deferring the reply, which will be finalized in subsequent subtasks. This approach ensures that the command handler is modular, maintainable, and ready for integration with the service layer.</content></update>\n</info added on 2025-05-12T22:49:41.390Z>\n<info added on 2025-05-12T22:52:29.464Z>\nDevelop a command parser that identifies command prefixes, separates arguments, and validates input format. Use Discord.js or Discord.py command handling frameworks to register commands and process options. Implement type conversion for arguments as needed.\n<info added on 2025-05-12T22:49:41.390Z>\n<update><timestamp>2025-05-12T22:49:35Z</timestamp><content>To implement the command parsing logic for the '/new season' command, begin by locating or creating the appropriate command file within the `src/commands/chat/` directory, such as `new-season.ts`. Use the Discord.js `SlashCommandBuilder` to define the command, specifying all required and optional options as outlined in the PRD and schema definition. These options include the season name (required, string), open duration (optional, string), min and max players (optional, integers), turn pattern (optional, string), and various timeout options (optional, strings). Implement the `execute` async function within the module, which will receive the `ChatInputCommandInteraction` object. Inside this function, extract each option using the appropriate `interaction.options` methods (e.g., `getString`, `getInteger`). Perform basic validation on the extracted values, such as checking for required fields and ensuring string formats for durations and timeouts are valid. Structure the validated options into an object suitable for passing to the `SeasonService` (to be implemented in the next subtask). Add a placeholder comment for the service call and for deferring the reply, which will be finalized in subsequent subtasks. This approach ensures that the command handler is modular, maintainable, and ready for integration with the service layer.</content></update>\n<update><timestamp>2025-05-12T22:52:19Z</timestamp><content>The command parsing logic for the '/newseason' command has been completed. The implementation is located in `src/commands/chat/new-season-command.ts`, where the `SlashCommandBuilder` data is defined as `newSeasonCommandData`. The command supports the following options: `name` (required, string), `open_duration` (optional, string), `min_players` (optional, integer), `max_players` (optional, integer), `turn_pattern` (optional, string), `claim_timeout` (optional, string), `writing_timeout` (optional, string), and `drawing_timeout` (optional, string). The `execute` function parses these options from the `ChatInputCommandInteraction` using appropriate methods such as `getString` and `getInteger`. Basic validation ensures that `min_players` is not greater than `max_players` and that required fields are present. The extracted and validated options are structured into a `seasonOptions` object, ready for use by the upcoming `SeasonService`. The command is exported from `src/commands/chat/index.ts` as `NewSeasonCommand`. Placeholders for service interaction and reply/error handling are in place for future subtasks.</content></update>\n</info added on 2025-05-12T22:52:29.464Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Build Service Invocation Layer",
          "description": "Create service classes that handle business logic separate from command handling",
          "dependencies": [
            1
          ],
          "details": "Develop service classes that encapsulate the core functionality. Implement methods that will be called by command handlers. Ensure proper separation of concerns between command parsing and business logic execution. Design clean interfaces for service methods.\n<info added on 2025-05-12T21:26:54.125Z>\nIntegrate with the existing SeasonService (Task 5) and call its method responsible for creating a new season record in the database using the parsed command options and user ID as creator. Ensure the service layer is invoked after command parsing is complete and all required data is available. Handle potential errors from the service layer, such as validation failures or database errors, and propagate appropriate error messages back to the command handler. Design the service interface to accept all necessary parameters for season creation, including user context and parsed options, and ensure it returns a clear result indicating success or failure.\n</info added on 2025-05-12T21:26:54.125Z>",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement Database Operations",
          "description": "Create database models and CRUD operations for storing command data",
          "dependencies": [
            2
          ],
          "details": "Design database schema for storing relevant information. Implement create, read, update, and delete operations. Ensure proper transaction handling and data validation. Create a repository layer to abstract database operations from service layer.\n<info added on 2025-05-12T21:27:09.159Z>\nWithin the SeasonService method called by the command handler (subtask 6.2), implement the logic to create the actual Season record in the database using Prisma client. This involves setting the initial status (e.g., PENDING), associating the creator, storing any parsed configuration overrides, and generating a unique, user-friendly season identifier if not handled automatically by the database. Ensure proper transaction handling and data validation. Create a repository layer to abstract database operations from the service layer, and design the database schema to store all relevant information for the Season entity, including creator association, status, configuration overrides, and unique identifier.\n</info added on 2025-05-12T21:27:09.159Z>",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Develop Error Handling and DM Notification System",
          "description": "Implement comprehensive error handling and direct message notification logic",
          "dependencies": [
            2,
            3
          ],
          "details": "Create error handling middleware that catches exceptions at different levels. Implement user-friendly error messages. Develop a notification system that sends direct messages to users based on events or errors. Ensure proper logging of errors for debugging purposes.\n<info added on 2025-05-12T21:27:22.895Z>\n<update timestamp=\"2025-05-12T21:27:19Z\">Implement the logic to send a Direct Message to the season creator immediately after successful season creation, prompting them to take their initial turn (such as issuing a '/ready' command or similar, based on future turn logic). Integrate with the messaging layer (Task 27) to ensure the DM is properly formatted and user-friendly. Implement specific error handling for the /new season command, catching and logging errors from parsing, service calls, or database operations. Provide clear, actionable feedback to the user for common scenarios (e.g., 'Season name already exists', 'Invalid configuration option'). Ensure all errors are logged for debugging and future improvements.</update>\n</info added on 2025-05-12T21:27:22.895Z>",
          "status": "done"
        }
      ]
    },
    {
      "id": 7,
      "title": "Implement '/join season' Command",
      "description": "The core logic for the `/join season:<id>` slash command handler in `src/commands/chat` has been implemented. This includes parsing the `season_id`, validating the season state, adding the user as a player (creating a new player record if necessary), and providing informative feedback. Integration tests covering various scenarios have also been completed.",
      "status": "in-progress",
      "dependencies": [
        2,
        5
      ],
      "priority": "medium",
      "details": "Implementation Plan:\n1. Create a new command file for `/join season` in `src/commands/chat`. (Completed as part of 701)\n2. Define the command structure with a required `season_id` option (e.g., using Discord.js builders). (Completed as part of 701)\n3. In the command handler: (Completed as part of 701)\n    a. Retrieve the `season_id` option value and the user executing the command (their Discord user ID and username). (Completed as part of 701)\n    b. Call `SeasonService.findSeasonById(seasonId)` to fetch the season details from the database. (Completed as part of 701)\n    c. Validate the fetched season: (Completed as part of 701)\n        i. Ensure the season exists (check if `findSeasonById` returned a season). (Completed as part of 701)\n        ii. Ensure the season is currently open for joining. This typically means its status should be 'open' or 'pending_start'. It should NOT be 'active', 'closed', or 'archived'. (Completed as part of 701)\n    d. If all validations pass, call `SeasonService.addPlayerToSeason(userId, seasonId)`. This logic now includes checking if a player record exists for the user's Discord ID and creating one if necessary, using their Discord username. (Completed as part of 701)\n    e. Respond to the user with an ephemeral message indicating success or failure. Include specific reasons for failure, such as 'Season not found', 'Season is not open for joining', or 'You have already joined this season'. (Completed as part of 701)\n4. Implement appropriate error handling for potential issues during database operations or unexpected errors. (Completed as part of 701)",
      "testStrategy": "Implement and run tests according to the project's testing guidelines (TECHNICAL_ARCHITECTURE.md):\n\n1.  **Manual/Integration Testing (via Discord):** Use the `/join season` command in a test Discord server with various inputs:\n    -   Use a valid `season_id` for a season that is 'open' or 'pending_start'. Verify the user is added as a player to that season in the database (creating a new player record if they didn't have one) and a success message is received.\n    -   Use a valid `season_id` for a season that is 'active', 'closed', or 'archived'. Verify an appropriate error message is returned (e.g., 'Season is not open for joining') and the user is NOT added.\n    -   Use an invalid or non-existent `season_id`. Verify an appropriate error message is returned (e.g., 'Season not found').\n    -   Attempt to join a season the user has already joined. Verify an appropriate error message is returned (e.g., 'You have already joined this season').\n    -   Test edge cases like invalid input format for the ID (if applicable based on Discord.js option type).\n\n2.  **Integration Tests (Database Interaction):** Integration tests simulating command execution logic, interacting with a test database but *without* involving the Discord API, have been completed in `tests/commands/chat/joinSeason.integration.test.ts`. These tests cover:\n    -   Successful joining of an open season for a new player (player record created).\n    -   Successful joining of an open season for an existing player.\n    -   Attempting to join a non-existent season.\n    -   Attempting to join a season that is not open for joining (e.g., 'active', 'closed').\n    -   Attempting to join a season the user has already joined.\n    -   Error handling for database issues.\n\n3.  **Unit Tests (Logic Layer):** Write unit tests for any pure logic functions extracted from the command handler, focusing on validation rules and data processing, independent of database or Discord interactions.",
      "subtasks": [
        {
          "id": 701,
          "description": "Implement the command handler logic in `src/commands/chat/joinSeason.ts`. This includes parsing options, validating season state, adding the player (creating a player record if needed), and sending responses.",
          "status": "done"
        },
        {
          "id": 702,
          "description": "Add integration tests for the `/join season` command logic against a test database, covering success cases (new/existing player), invalid season, closed season, and already joined scenarios.",
          "status": "done"
        },
        {
          "id": 703,
          "description": "Add unit tests for any extracted logic functions related to season joining.",
          "status": "done",
          "details": "<info added on 2025-05-16T00:33:52.360Z>\n<update><timestamp>2025-05-16T00:33:48Z</timestamp><content>Analysis of the command handler `src/commands/chat/joinSeason.ts` reveals that it primarily orchestrates calls to `SeasonService` and manages Discord interactions. The core business logic—such as finding the season, adding a player, and status checks—is encapsulated within `SeasonService` methods, which are already covered by integration tests (subtask 702). The remaining logic in the command handler itself consists of simple validation and direct interaction handling, with no extracted functions that warrant separate unit tests. Therefore, no new unit tests are required for this subtask. This assessment is based on the current code structure and test coverage.</content></update>\n</info added on 2025-05-16T00:33:52.360Z>"
        },
        {
          "id": 704,
          "description": "Manually test the `/join season` command in a test Discord server.",
          "status": "todo"
        }
      ]
    },
    {
      "id": 8,
      "title": "Implement Season Activation Logic",
      "description": "Implement the logic responsible for transitioning a season from PENDING (waiting for players) to ACTIVE. This logic should be triggered either when the `max_players` limit is reached or when the `open_duration` timeout expires (requires Task Scheduler). Upon activation, create N games for N players in the season and trigger the initial turn OFFERs for each player via DM.",
      "status": "in-progress",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "",
      "testStrategy": "Implement comprehensive tests including unit tests for core logic, integration tests verifying database interactions, and end-to-end tests simulating player joins and timeout scenarios. Verify season status transitions, game creation, player assignments, and initial turn offers (including Discord DMs in end-to-end tests).",
      "subtasks": [
        {
          "id": 8.1,
          "description": "Implement the core season activation logic (check conditions, update season status, create games, assign players)",
          "status": "pending"
        },
        {
          "id": 8.2,
          "description": "Integrate with Task Scheduler for the `open_duration` timeout trigger",
          "status": "pending"
        },
        {
          "id": 8.3,
          "description": "Implement the logic to send initial turn offer DMs upon activation",
          "status": "pending"
        },
        {
          "id": 8.4,
          "description": "Implement unit tests for the core season activation logic",
          "status": "pending"
        },
        {
          "id": 8.5,
          "description": "Implement integration tests verifying database interactions during activation",
          "status": "pending"
        },
        {
          "id": 8.6,
          "description": "Implement end-to-end tests covering player join and timeout scenarios, verifying full flow including Discord DMs",
          "status": "pending"
        }
      ]
    },
    {
      "id": 9,
      "title": "Implement Turn State Management",
      "description": "Implement the state management logic for turns within the `TurnService`. This involves methods to update the state of a turn in the database, transitioning between CREATED, AVAILABLE, OFFERED, PENDING, COMPLETED, and SKIPPED states as defined in the PRD. Ensure atomic updates where necessary.",
      "status": "pending",
      "dependencies": [
        1,
        5
      ],
      "priority": "medium",
      "details": "",
      "testStrategy": "Implement testing requirements as documented in TECHNICAL_ARCHITECTURE.md. This includes writing unit tests for the logic layer functionality within the `TurnService` methods and integration tests against a test database to verify state transitions and atomic updates.",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Setup Direct Message Handling Framework",
      "description": "Set up the Discord.js listener to handle Direct Messages sent to the bot. Implement logic to identify the context of the DM (e.g., is the user expected to send a `/ready` command, or are they submitting a turn for a specific game/turn?). Route the DM content to the appropriate handling logic.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "details": "Implement the core framework for receiving and routing Direct Messages. This includes setting up the Discord.js event listener for 'messageCreate' and adding initial logic to distinguish between different types of expected DM interactions.",
      "testStrategy": "Implement unit tests for the core routing logic. Implement integration tests that simulate receiving a DM and routing it, using a test database but without interacting with the Discord API. Additionally, manually send various types of DMs to the bot (plain text, image, slash command) to verify the bot receives the DMs and the framework correctly identifies the sender and message type, routing it to a placeholder handler.",
      "subtasks": [
        {
          "id": 1,
          "description": "Implement Discord.js listener for 'messageCreate' event to capture DMs.",
          "status": "pending"
        },
        {
          "id": 2,
          "description": "Add initial logic to identify DM sender and basic message type.",
          "status": "pending"
        },
        {
          "id": 3,
          "description": "Implement placeholder routing mechanism for different DM contexts.",
          "status": "pending"
        },
        {
          "id": 4,
          "description": "Write unit tests for the DM routing logic.",
          "status": "pending"
        },
        {
          "id": 5,
          "description": "Write integration tests simulating DM reception and routing against a test database.",
          "status": "pending"
        },
        {
          "id": 6,
          "description": "Perform manual testing by sending various DMs to the bot.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 11,
      "title": "Implement '/ready' Command Handling (DM)",
      "description": "Implement the handler for the `/ready` command when used in a Direct Message. This handler should validate that the user has a turn currently in the OFFERED state. If valid, call `TurnService.claimTurn` to update the turn state to PENDING (ASSIGNED), cancel the associated claim timeout timer via the Task Scheduler, and schedule the appropriate submission timeout timer (writing or drawing). Send a confirmation DM to the player.",
      "status": "pending",
      "dependencies": [
        5,
        9,
        10
      ],
      "priority": "medium",
      "details": "",
      "testStrategy": "Implement the following testing types:\n\n1.  **Unit Tests:** Test the core logic components of the command handler in isolation, mocking external dependencies like the database, TurnService, and Task Scheduler. Verify correct validation, calls to services, and timer interactions.\n2.  **Integration Tests:** Test the command handler's interaction with the database using a test database instance. Verify that the turn state is correctly updated to PENDING (ASSIGNED) and that appropriate data is persisted.\n3.  **End-to-End/Manual Testing:** Offer a turn to a test player. Have the player use `/ready` in DM. Verify the turn state changes to PENDING in the DB. Verify the claim timer is cancelled and a submission timer is scheduled via the Task Scheduler (manual verification or logging). Test using `/ready` when no turn is offered and verify an appropriate error message is returned to the user.",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement Turn Submission Handling (DM)",
      "description": "Implement the logic within the DM handling framework to process turn submissions (text for writing turns, image for drawing turns). This logic should validate that the user has a turn currently in the PENDING state. If valid, call `TurnService.submitTurn` to update the turn state to COMPLETED, save the submitted content (text or image URL), cancel the submission timeout timer via the Task Scheduler, and trigger the process to find and offer the next turn in that game.",
      "status": "pending",
      "dependencies": [
        5,
        9,
        10
      ],
      "priority": "medium",
      "details": "Implement the necessary command handler for processing turn submissions received via Direct Messages. This involves parsing the incoming message (checking for text or attachments), validating the user's current turn state, interacting with the `TurnService` to update the turn and save content, and coordinating with the Task Scheduler for timer cancellation and the game progression logic for finding the next turn.",
      "testStrategy": "Implement comprehensive tests covering the submission handling logic:\n1.  **Integration Tests:** Test the command handler's interaction with the database using a test database instance. Verify turn state updates, content saving, and timer cancellation logic without involving Discord.\n2.  **Unit Tests:** Test the core logic components of the command handler in isolation, mocking dependencies like the database or external services.\n3.  **End-to-End Test (Manual/Automated):** Have a test player claim a turn (PENDING) in a test game. Have them submit text (for writing) or an image (for drawing) in DM. Verify the turn state changes to COMPLETED, content is saved in the DB, the submission timer is cancelled, and the next turn is offered (if applicable).",
      "subtasks": [
        {
          "id": 1201,
          "description": "Implement the core logic for validating turn submission and calling TurnService.submitTurn.",
          "status": "pending"
        },
        {
          "id": 1202,
          "description": "Integrate logic for saving submitted content (text or image URL).",
          "status": "pending"
        },
        {
          "id": 1203,
          "description": "Implement logic to cancel the submission timeout timer via the Task Scheduler.",
          "status": "pending"
        },
        {
          "id": 1204,
          "description": "Implement logic to trigger finding and offering the next turn after successful submission.",
          "status": "pending"
        },
        {
          "id": 1205,
          "description": "Write integration tests for the submission handling logic against a test database.",
          "status": "pending"
        },
        {
          "id": 1206,
          "description": "Write unit tests for the core logic components of the submission handling command.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 13,
      "title": "Implement Season Next Player Logic",
      "description": "Implement the core Next Player Logic algorithm for Season Games as detailed in the PRD (`MUSTs` and `SHOULDs`). This logic, likely residing in `src/game/` or `GameService`, determines which player should be OFFERED the next AVAILABLE turn in a specific game, considering who has played, turn types, and avoiding multiple pending turns for one player.",
      "status": "pending",
      "dependencies": [
        5,
        9
      ],
      "priority": "medium",
      "details": "",
      "testStrategy": "Implement comprehensive tests as per TECHNICAL_ARCHITECTURE.md:\n1.  Write unit tests specifically for the core logic layer function(s) that determine the next player. These tests should cover various scenarios: a new game, mid-game with players available, end-game with few players left, scenarios where players have pending turns, scenarios after a player is skipped. Verify the correct player is selected according to the PRD rules.\n2.  Write integration tests that interact with a test database to ensure the logic functions correctly within the application context, considering database state changes and interactions.",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Implement Turn Offering Mechanism",
      "description": "Implement the mechanism that triggers the selection and offering of the next turn. This should be called after a turn is COMPLETED or SKIPPED, or when a season is activated. It uses the Next Player Logic (Task 13) to find the next player, calls `TurnService.offerTurn` to update the state, sends the DM notification to the selected player, and schedules the claim timeout timer via the Task Scheduler.",
      "status": "pending",
      "dependencies": [
        5,
        9,
        13
      ],
      "priority": "medium",
      "details": "Implement the core logic for triggering the turn offering process. This involves:\n- Identifying the trigger points (Turn COMPLETED/SKIPPED, Season Activated).\n- Calling the Next Player Logic (Task 13) to determine the next player.\n- Updating the game state via `TurnService.offerTurn`.\n- Sending a Discord DM notification to the selected player.\n- Scheduling the turn claim timeout timer using the Task Scheduler.",
      "testStrategy": "Implement comprehensive tests covering the turn offering mechanism:\n1.  **Unit Tests:** Test the core logic components in isolation, particularly the selection and state update logic, mocking external dependencies like the database, Discord API, and Task Scheduler.\n2.  **Integration Tests:** Test the interaction between the turn offering logic and the database using a test database. Verify state changes are correctly persisted without involving Discord or the Task Scheduler directly.\n3.  **End-to-End/Manual Testing:** Complete or skip a turn in a test game. Verify the Turn Offering Mechanism is triggered. Verify the correct next player is selected (using Task 13), the turn state becomes OFFERED, the player receives a DM notification, and the claim timer is scheduled.",
      "subtasks": [
        {
          "id": "14.1",
          "description": "Implement the core logic for triggering and executing the turn offering process.",
          "status": "pending"
        },
        {
          "id": "14.2",
          "description": "Integrate with Next Player Logic (Task 13) to get the next player.",
          "status": "pending"
        },
        {
          "id": "14.3",
          "description": "Implement the call to `TurnService.offerTurn` to update game state.",
          "status": "pending"
        },
        {
          "id": "14.4",
          "description": "Implement sending the Discord DM notification to the selected player.",
          "status": "pending"
        },
        {
          "id": "14.5",
          "description": "Implement scheduling the turn claim timeout timer via the Task Scheduler.",
          "status": "pending"
        },
        {
          "id": "14.6",
          "description": "Write Unit Tests for the turn offering logic layer.",
          "status": "pending"
        },
        {
          "id": "14.7",
          "description": "Write Integration Tests for the turn offering mechanism against a test database.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 15,
      "title": "Integrate Task Scheduler",
      "description": "Integrate a Task Scheduler component into the bot architecture. This component is responsible for scheduling and triggering events based on time limits, specifically for claim timeouts (`claim_timeout`) and submission timeouts (`writing_timeout`, `drawing_timeout`) as defined in the season rules. It should be reliable and ideally persist scheduled tasks across bot restarts.",
      "details": "",
      "testStrategy": "Implement basic scheduling and triggering. Schedule a simple task for a short duration. Verify the task is executed at the correct time. Test scheduling multiple tasks.",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 16,
      "title": "Implement Claim Timeout Handler",
      "description": "Implement the handler logic that is triggered by the Task Scheduler when a `claim_timeout` occurs for an OFFERED turn. This handler should call `TurnService.dismissOffer` to revert the turn state to AVAILABLE and then trigger the Turn Offering Mechanism (Task 14) to find and offer the turn to another eligible player.",
      "status": "pending",
      "dependencies": [
        5,
        9,
        14,
        15
      ],
      "priority": "medium",
      "details": "Implement the handler logic. Ensure comprehensive testing is included, covering both integration tests against a test database and unit tests for the core logic, as per the requirements in TECHNICAL_ARCHITECTURE.md.",
      "testStrategy": "Implement integration tests using a test database to verify the handler's interaction with the database (state changes, task scheduling). Implement unit tests for the core logic within the handler and `TurnService.dismissOffer` to ensure correct state transitions and logic execution independent of the database or external services. Additionally, perform manual testing by offering a turn to a test player, letting the timeout expire, and verifying the state change and subsequent offering attempt.",
      "subtasks": [
        {
          "id": "16-1",
          "description": "Implement the core handler logic for claim timeout.",
          "status": "pending"
        },
        {
          "id": "16-2",
          "description": "Implement integration tests for the claim timeout handler against a test database.",
          "status": "pending"
        },
        {
          "id": "16-3",
          "description": "Implement unit tests for the claim timeout handler logic and related `TurnService` methods.",
          "status": "pending"
        },
        {
          "id": "16-4",
          "description": "Perform manual testing to verify the end-to-end flow.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 17,
      "title": "Implement Submission Timeout Handler",
      "description": "Implement the handler logic that is triggered by the Task Scheduler when a `writing_timeout` or `drawing_timeout` occurs for a PENDING turn. This handler should call `TurnService.skipTurn` to update the turn state to SKIPPED, send a DM notification to the player informing them they were skipped, and then trigger the Turn Offering Mechanism (Task 14) to find and offer the turn to another eligible player.",
      "status": "pending",
      "dependencies": [
        5,
        9,
        14,
        15
      ],
      "priority": "medium",
      "details": "Implement the core logic for the timeout handler. This involves:\n- Receiving the timeout event (e.g., from a message queue or scheduler trigger).\n- Identifying the specific turn that timed out.\n- Calling `TurnService.skipTurn` to update the turn state.\n- Sending a DM notification to the player who was skipped.\n- Triggering the Turn Offering Mechanism (Task 14).",
      "testStrategy": "Implement comprehensive tests covering the handler logic:\n1.  **Unit Tests:** Test the core logic components (e.g., service methods called by the handler) in isolation.\n2.  **Integration Tests:** Test the handler's interaction with the database (e.g., verifying turn state updates) using a test database. These tests should NOT interact with external services like Discord.\n3.  **End-to-End Test:** Have a test player claim a turn (PENDING) but do not have them submit content. Set a short submission timeout. Verify that after the timeout, the turn state changes to SKIPPED, the player receives a skipped message DM, and the Turn Offering Mechanism attempts to find another player.",
      "subtasks": [
        {
          "id": "17-1",
          "description": "Implement the core handler logic for processing timeout events.",
          "status": "pending",
          "details": "This includes receiving the event, identifying the turn, calling `TurnService.skipTurn`, and initiating the notification/offering process."
        },
        {
          "id": "17-2",
          "description": "Implement logic to send a DM notification to the skipped player.",
          "status": "pending",
          "details": "Utilize the appropriate messaging service to send a private message informing the player their turn was skipped due to timeout."
        },
        {
          "id": "17-3",
          "description": "Integrate triggering the Turn Offering Mechanism (Task 14) after skipping the turn.",
          "status": "pending",
          "details": "Ensure the handler correctly calls or signals the mechanism responsible for finding the next eligible player."
        },
        {
          "id": "17-4",
          "description": "Write Unit Tests for the handler's logic components.",
          "status": "pending",
          "details": "Focus on testing individual functions and methods called by the handler in isolation, mocking dependencies as needed."
        },
        {
          "id": "17-5",
          "description": "Write Integration Tests for the handler's database interactions.",
          "status": "pending",
          "details": "Use a test database to verify that the handler correctly updates the turn state to SKIPPED. These tests should not involve Discord or other external services."
        },
        {
          "id": "17-6",
          "description": "Perform End-to-End testing of the timeout scenario.",
          "status": "pending",
          "details": "Manually or automatically simulate the full flow: player claims turn, timeout occurs, verify state change, DM received, and offering mechanism triggered."
        }
      ]
    },
    {
      "id": 18,
      "title": "Implement Game Completion Check (Season)",
      "description": "Implement the logic to check if a game within a season is completed. This check should be performed after a turn is successfully COMPLETED or SKIPPED. A game is completed when every player in the season has either COMPLETED or been SKIPPED for their turn in that specific game.",
      "status": "pending",
      "dependencies": [
        5,
        9
      ],
      "priority": "medium",
      "details": "Implement the necessary logic within the game or season management service to determine game completion status based on player turn states.",
      "testStrategy": "Implement unit tests for the core logic layer function that determines game completion based on player turn states. Implement integration tests against a test database to verify the end-to-end process: setting up a season and game, simulating player turns (completed and skipped), and confirming the game state correctly transitions to COMPLETED when the criteria are met. Ensure these integration tests do not interact with external services like Discord.",
      "subtasks": [
        {
          "id": "18-1",
          "description": "Implement the core logic function to check game completion based on player turn states.",
          "status": "pending"
        },
        {
          "id": "18-2",
          "description": "Integrate the game completion check into the turn completion/skip process.",
          "status": "pending"
        },
        {
          "id": "18-3",
          "description": "Write unit tests for the game completion logic function.",
          "status": "pending"
        },
        {
          "id": "18-4",
          "description": "Write integration tests against a test database to verify game completion flow.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 19,
      "title": "Implement Season Completion Check",
      "description": "Implement the logic to check if a season is completed. This check should be performed after a game within the season is marked as COMPLETED. A season is completed when all games within that season are completed.",
      "details": "",
      "testStrategy": "Set up a test season with multiple games. Play through all games, ensuring they become COMPLETED. Verify the season state correctly transitions to COMPLETED when all games are finished.",
      "priority": "medium",
      "dependencies": [
        5,
        18
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 20,
      "title": "Implement Season Completion Announcement/DM",
      "description": "Implement the logic to format and deliver the results when a season is completed. This involves retrieving the full sequence of turns and content for each game in the season from the database, formatting it into a readable output, and posting it in the channel where the season was initiated (or DMing it to players if initiated via DM). This should utilize the messaging layer (Task 27).",
      "details": "",
      "testStrategy": "Complete a test season. Verify that the full sequences for all games are retrieved, formatted correctly, and posted in the designated channel or DM'd to players.",
      "priority": "medium",
      "dependencies": [
        5,
        18,
        19
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 21,
      "title": "Implement '/status season' Command",
      "description": "Implement the `/status season:<name>` slash command handler in `src/commands/chat`. This handler should parse the season identifier, query the database via the `SeasonService` to get the current state of the season and its games (e.g., how many turns are left per game, which turns are pending/offered), format this information using the messaging layer (Task 27), and send it as a response.",
      "status": "pending",
      "dependencies": [
        2,
        5
      ],
      "priority": "medium",
      "details": "",
      "testStrategy": "Implement integration tests that verify the command's database interaction and data retrieval logic using a test database, without involving Discord. Implement unit tests for the command's logic layer (parsing, data processing, formatting). Also, manually test the `/status season` command via Discord for active and completed seasons to verify the command returns accurate information about the season's progress, including the state of games and turns, and that the output is correctly formatted.",
      "subtasks": [
        {
          "id": "21-1",
          "description": "Implement the core command handler logic for `/status season`.",
          "status": "pending"
        },
        {
          "id": "21-2",
          "description": "Integrate with `SeasonService` to fetch season and game data.",
          "status": "pending"
        },
        {
          "id": "21-3",
          "description": "Format the retrieved data using the messaging layer.",
          "status": "pending"
        },
        {
          "id": "21-4",
          "description": "Implement integration tests for the command's database interaction and data retrieval.",
          "status": "pending"
        },
        {
          "id": "21-5",
          "description": "Implement unit tests for the command's logic layer (parsing, data processing, formatting).",
          "status": "pending"
        }
      ]
    },
    {
      "id": 22,
      "title": "Implement Admin Command: Terminate Season",
      "description": "Implement the `/admin terminate season:<id>` slash command handler in `src/commands/chat`. This handler should include permission checks to ensure only authorized users can use it. It should call the `SeasonService` to mark the specified season as TERMINATED in the database and potentially clean up or mark related games/turns appropriately.",
      "status": "pending",
      "dependencies": [
        2,
        5
      ],
      "priority": "medium",
      "details": "As per TECHNICAL_ARCHITECTURE.md, this command implementation requires both integration tests against a test database and unit tests for the core logic.",
      "testStrategy": "Implement integration tests that use a test database to verify the command handler's interaction with the `SeasonService` and database state changes (season status, related entities). Implement unit tests for the permission checks and any specific logic within the command handler itself, mocking dependencies like the `SeasonService`. Also, perform manual testing using the `/admin terminate season` command with a test season as an admin to verify the season state changes to TERMINATED in the database. Manually test using the command without admin permissions and verify it is rejected.",
      "subtasks": [
        {
          "id": 1,
          "description": "Implement the core logic for the `/admin terminate season` command handler, including permission checks.",
          "status": "pending"
        },
        {
          "id": 2,
          "description": "Implement integration tests for the `/admin terminate season` command handler against a test database.",
          "status": "pending"
        },
        {
          "id": 3,
          "description": "Implement unit tests for the logic within the `/admin terminate season` command handler.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 23,
      "title": "Implement Admin Commands: Ban/Unban Player",
      "description": "Implement the `/admin ban user:@user` and `/admin unban user:@user` slash command handlers in `src/commands/chat`. These handlers should include permission checks. They should call the `PlayerService` to update the player's state (BANNED/NOT_BANNED) in the database. Banned players should not be able to join new seasons or be offered turns.",
      "status": "pending",
      "dependencies": [
        2,
        5
      ],
      "priority": "medium",
      "details": "Implement the command logic within `src/commands/chat/admin.ts`. Ensure proper error handling for invalid user mentions or permission issues. The command should interact with the `PlayerService` to update the player's `status` field in the database.",
      "testStrategy": "Implement integration tests using a test database to verify the command handler correctly updates the player status and handles edge cases (e.g., banning an already banned user). Implement unit tests for the core logic within the command handler or any extracted helper functions. Manually test the commands in a development environment: Use the `/admin ban` command on a test user as an admin. Verify the user's state changes to BANNED in the database. Attempt to join a season or be offered a turn with the banned user and verify it fails. Use `/admin unban` and verify the user can then participate.",
      "subtasks": [
        {
          "id": 1,
          "description": "Implement `/admin ban` command handler in `src/commands/chat/admin.ts`",
          "status": "pending"
        },
        {
          "id": 2,
          "description": "Implement `/admin unban` command handler in `src/commands/chat/admin.ts`",
          "status": "pending"
        },
        {
          "id": 3,
          "description": "Add permission checks to ban/unban handlers",
          "status": "pending"
        },
        {
          "id": 4,
          "description": "Integrate ban/unban handlers with `PlayerService` to update player status",
          "status": "pending"
        },
        {
          "id": 5,
          "description": "Implement integration tests for ban/unban commands against a test database",
          "status": "pending"
        },
        {
          "id": 6,
          "description": "Implement unit tests for the ban/unban command logic",
          "status": "pending"
        },
        {
          "id": 7,
          "description": "Manually test ban/unban commands in development environment",
          "status": "pending"
        }
      ]
    },
    {
      "id": 24,
      "title": "Implement Admin Commands: List Seasons/Players",
      "description": "Implement the `/admin list seasons` and `/admin list players` slash command handlers in `src/commands/chat`. These handlers should include permission checks. They should query the database via the service layer to retrieve lists of active seasons and players (potentially filtered by season or status) and display this information.",
      "status": "pending",
      "dependencies": [
        2,
        5
      ],
      "priority": "medium",
      "details": "As per TECHNICAL_ARCHITECTURE.md, this command implementation requires both integration tests against a test database and unit tests for the command's core logic.",
      "testStrategy": "Implement integration tests that verify the command logic interacts correctly with a test database to retrieve season and player data. Implement unit tests for the command's logic layer (e.g., data formatting, permission checks). Manually test the `/admin list seasons` and `/admin list players` commands as an admin in a development environment to verify they return lists of seasons and players currently in the database via Discord.",
      "subtasks": [
        {
          "id": 2401,
          "description": "Implement `/admin list seasons` command handler with permission checks and database query.",
          "status": "pending"
        },
        {
          "id": 2402,
          "description": "Implement `/admin list players` command handler with permission checks and database query.",
          "status": "pending"
        },
        {
          "id": 2403,
          "description": "Add integration tests for `/admin list seasons` command against a test database.",
          "status": "pending"
        },
        {
          "id": 2404,
          "description": "Add integration tests for `/admin list players` command against a test database.",
          "status": "pending"
        },
        {
          "id": 2405,
          "description": "Add unit tests for the logic layer of the list seasons/players commands (e.g., data formatting).",
          "status": "pending"
        }
      ]
    },
    {
      "id": 25,
      "title": "Implement Basic Configuration Command ('/config seasons')",
      "description": "Implement the `/config seasons [options]` slash command handler in `src/commands/chat`. This handler should allow administrators or authorized users to view the current default configuration settings for seasons (e.g., timeouts, min/max players). Optionally, allow setting these defaults, which would require persisting them (e.g., in the database or a config file).",
      "status": "pending",
      "dependencies": [
        2,
        5
      ],
      "priority": "medium",
      "details": "",
      "testStrategy": "Implement integration tests that interact with a test database to verify command behavior without Discord interaction. Implement unit tests for the core logic layer of the command handler. Additionally, manually test the command using `/config seasons` to view current settings and, if setting is implemented, test updating a setting and verifying the change is reflected via the command and potentially direct database inspection.",
      "subtasks": []
    },
    {
      "id": 26,
      "title": "Implement Comprehensive Error Handling and User Feedback",
      "description": "Implement robust error handling across all command handlers and DM processing logic. Ensure that invalid user input, command failures, service layer errors, or database issues are caught and result in clear, informative error messages being sent back to the user via the messaging layer (Task 27).",
      "details": "",
      "testStrategy": "Intentionally trigger errors in various user flows (e.g., invalid command options, trying to join a non-existent season, submitting the wrong content type). Verify that the bot does not crash and provides helpful error messages to the user.",
      "priority": "medium",
      "dependencies": [
        2,
        10
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 27,
      "title": "Refine and Integrate Messaging Layer",
      "description": "Refine and fully implement the messaging layer (`src/messaging/`) as described in the architecture. This layer is responsible for taking structured data payloads and message instructions from the service layer and generating the final, user-facing strings for all bot replies (DMs, public channel messages, ephemeral messages). Integrate i18n if planned, otherwise use simple string formatting. Ensure all command handlers and DM processing logic use this layer for output.\n\nArchitectural Decisions related to this layer:\n1. Services should be designed to be chat platform-independent. Core logic should be abstracted from platform-specific APIs.\n2. Service methods invoked by commands should return a common, platform-agnostic data structure (e.g., a `MessageInstruction` type). This structure will be translated by a platform-specific adapter (the messaging layer itself or a component it uses).",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "Define the `MessageInstruction` data structure used for communication between services and the messaging layer. Implement the translation logic within the messaging layer to convert this structure into platform-specific message formats.",
      "testStrategy": "Review all user-facing messages generated by the bot. Verify they are consistently formatted and generated via the messaging layer. Test messages with different data payloads (represented by the `MessageInstruction` structure) to ensure correct formatting and translation.",
      "subtasks": []
    },
    {
      "id": 28,
      "title": "Comprehensive Testing and Refinement (MVP)",
      "description": "Conduct comprehensive testing of all implemented MVP features. This includes writing unit tests for pure logic functions (`src/game/`), integration tests for services and command handlers, and manual end-to-end testing of the full season game flow, including season creation, joining, turn taking (writing/drawing), `/ready` command, timeouts (claim and submission), skipping players, game completion, season completion, and the completion announcement/DM. Test admin commands and status command. Refactor code based on testing feedback.",
      "details": "",
      "testStrategy": "Execute all unit and integration tests. Perform manual testing following the Season Game Flow and Key User Flows described in the PRD. Create test scenarios specifically for risks identified (Next Player Logic complexity, Timeout handling, End-of-Season edge cases). Document test results and bugs.",
      "priority": "medium",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 29,
      "title": "Refactor /new season command handler to align with architecture",
      "description": "Refactor the '/new season' command handler to align with the technical architecture, incorporating structured service responses, error handling, and the message generation layer.",
      "details": "Refactor the command handler located at `src/commands/chat/new-command.ts` to strictly adhere to the principles outlined in `TECHNICAL_ARCHITECTURE.md`. This involves several key changes:\n\n1.  **Prisma Client Handling:** Ensure the Prisma client is accessed or passed in a manner consistent with the architectural guidelines (e.g., via context, dependency injection, or a dedicated factory/singleton if appropriate for the architecture).\n2.  **SeasonService Integration:** Modify the `SeasonService` (and potentially its interface/return types) to return structured results. Instead of returning raw data or throwing errors directly, the service should return an object or union type that clearly indicates success or failure, and for success, includes the necessary data (e.g., season ID) along with structured instructions for message generation (e.g., a message key and payload for Linguine.js).\n3.  **Structured Error Handling:** The `SeasonService` should be responsible for identifying specific error conditions (e.g., user already has an active season) and returning these as structured error types (e.g., custom error classes, enums, or a discriminated union) rather than throwing generic errors or returning simple booleans/strings.\n4.  **Message Generation Layer:** The command handler must utilize the existing Lang service (leveraging Linguine.js) for *all* user-facing messages. This includes:\n    *   The initial success reply in the channel.\n    *   The Direct Message sent to the user.\n    *   *All* error messages (e.g., validation errors, service-level errors like 'user already has a season'). The handler should receive the structured error type from the service and use the Lang service to generate the appropriate localized error message.\n\nThe command handler should become a thin layer that primarily handles parsing input, calling the service, receiving the structured result/error, and using the message generation layer to format and send the appropriate response(s) to the user.",
      "testStrategy": "A comprehensive testing strategy is required to ensure the refactoring is correct and robust:\n\n1.  **Unit Tests for Command Handler:**\n    *   Mock the `SeasonService` to return various structured success and error scenarios (e.g., successful creation, user already has season, database error).\n    *   Mock the `LangService` to control the output strings for given message keys and payloads.\n    *   Verify that for each mocked service response, the command handler correctly calls the `LangService` with the expected message key and payload.\n    *   Verify that the command handler sends the correct type of message (reply, DM) with the string returned by the mocked `LangService`.\n    *   Test edge cases like missing options (if applicable after parsing).\n2.  **Unit Tests for SeasonService:**\n    *   Mock the Prisma client methods used by the service (e.g., `create`, `findUnique`).\n    *   Verify that the service correctly interacts with the mocked Prisma client.\n    *   Verify that the service returns the expected structured success object (containing data and message instructions) upon successful season creation.\n    *   Verify that the service returns the correct structured error type for known error conditions (e.g., mock `findUnique` to return an existing season for the user and verify the 'user already has season' error type is returned).\n    *   Verify that unexpected database errors are caught and wrapped/returned as a generic service error type.\n3.  **Manual Testing:**\n    *   Deploy the changes to a test environment.\n    *   Execute the `/new season` command as a new user and verify the correct success reply and DM are received, and the season is created in the database.\n    *   Execute the `/new season` command as a user who already has an active season and verify the correct error message is displayed (using the message generation layer).\n    *   (If possible) Simulate a database error during season creation and verify a graceful error message is displayed to the user (using the message generation layer).\n    *   Verify all user-facing messages (success, error, DM) are correctly formatted and localized (if localization is implemented).",
      "status": "done",
      "dependencies": [
        6
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Refactor Prisma Client Handling",
          "description": "Update the /new season command to use a single, shared Prisma Client instance following best practices to avoid multiple instances and ensure efficient database access.",
          "dependencies": [],
          "details": "Implement a global Prisma Client instance as recommended for Next.js and Node.js applications. Ensure that the command does not create new Prisma Client instances on each invocation, and refactor imports or instantiation as needed.\n<info added on 2025-05-13T15:20:59.789Z>\nTo ensure efficient and reliable database access, refactor the /new season command handler to use a single, globally managed Prisma Client instance. This approach prevents the creation of multiple Prisma Client instances, which can occur during development due to Next.js hot-reloading or repeated command invocations, and helps avoid resource leaks and unexpected behavior. Implement a dedicated module at `src/lib/prisma.ts` that exports a single Prisma Client instance, initialized either as a global variable in development or as a fresh instance in production. Remove all local Prisma Client instantiations and disconnection logic from the command handler, and update imports to use the shared instance. The SeasonService should continue to accept PrismaClient via its constructor, requiring no further changes. This pattern aligns with best practices for Prisma usage in Next.js and Node.js applications, as documented in the Prisma and Next.js guides[1][5].\n</info added on 2025-05-13T15:20:59.789Z>\n<info added on 2025-05-13T15:21:50.881Z>\nTo ensure efficient and reliable database access, the /new season command handler has been refactored to use a single, globally managed Prisma Client instance. This approach prevents the creation of multiple Prisma Client instances, which can occur during development due to Next.js hot-reloading or repeated command invocations, and helps avoid resource leaks and unexpected behavior. A dedicated module at `src/lib/prisma.ts` has been implemented, exporting a single Prisma Client instance initialized either as a global variable in development or as a fresh instance in production. All local Prisma Client instantiations and disconnection logic have been removed from the command handler, and imports have been updated to use the shared instance. The SeasonService continues to accept PrismaClient via its constructor, requiring no further changes. This pattern aligns with best practices for Prisma usage in Next.js and Node.js applications, as documented in the Prisma and Next.js guides[1][5].\n<info added on 2025-05-13T15:20:59.789Z>\nImplementation update: The `src/lib/prisma.ts` module has been created and now initializes and exports a single, global Prisma Client instance, including logic to reuse the instance in development to prevent exhausting database connections. The `src/commands/chat/new-command.ts` file has been refactored to remove local `PrismaClient` instantiation, import the global `prisma` instance from `../../lib/prisma.js`, and instantiate the `SeasonService` with this global instance. All local `prisma.$disconnect()` calls have been removed, as the lifecycle of the global Prisma instance is managed at the application level. This ensures the `/new season` command uses a single, shared client instance, aligning with architectural best practices.\n</info added on 2025-05-13T15:21:50.881Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Integrate SeasonService",
          "description": "Refactor the command logic to delegate season-related business logic to the SeasonService, ensuring a clean separation of concerns.",
          "dependencies": [
            1
          ],
          "details": "Replace direct database calls or business logic in the command handler with calls to SeasonService methods. Ensure that all season creation, validation, and retrieval logic is encapsulated within the service.\n<info added on 2025-05-13T15:34:37.875Z>\nReplace direct database calls or business logic in the command handler with calls to SeasonService methods. Ensure that all season creation, validation, and retrieval logic is encapsulated within the service. Specifically, update the `createSeason` method in `src/services/SeasonService.ts` to include validation for `minPlayers` and `maxPlayers`, returning a structured error if `maxPlayers` is less than `minPlayers`. Refactor the command handler in `src/commands/chat/new-command.ts` to remove the validation logic from the `execute` method and instead handle the structured error returned by the service, displaying an appropriate error message to the user. This approach centralizes business logic and validation within the service layer, promoting maintainability and separation of concerns.\n</info added on 2025-05-13T15:34:37.875Z>\n<info added on 2025-05-13T15:36:02.037Z>\nReplace direct database calls or business logic in the command handler with calls to SeasonService methods. Ensure that all season creation, validation, and retrieval logic is encapsulated within the service. Specifically, update the `createSeason` method in `src/services/SeasonService.ts` to include validation for `minPlayers` and `maxPlayers`, returning a structured error if `maxPlayers` is less than `minPlayers`. Refactor the command handler in `src/commands/chat/new-command.ts` to remove the validation logic from the `execute` method and instead handle the structured error returned by the service, displaying an appropriate error message to the user. This approach centralizes business logic and validation within the service layer, promoting maintainability and separation of concerns.\n<info added on 2025-05-13T15:34:37.875Z>\nReplace direct database calls or business logic in the command handler with calls to SeasonService methods. Ensure that all season creation, validation, and retrieval logic is encapsulated within the service. Specifically, update the `createSeason` method in `src/services/SeasonService.ts` to include validation for `minPlayers` and `maxPlayers`, returning a structured error if `maxPlayers` is less than `minPlayers`. Refactor the command handler in `src/commands/chat/new-command.ts` to remove the validation logic from the `execute` method and instead handle the structured error returned by the service, displaying an appropriate error message to the user. This approach centralizes business logic and validation within the service layer, promoting maintainability and separation of concerns.\n<info added on 2025-05-13T15:34:37.875Z>\nImplementation update: The `createSeason` method in `src/services/SeasonService.ts` now performs validation at the start to ensure `maxPlayers` is not less than `minPlayers` (if both are provided). If validation fails, it returns a `MessageInstruction` with `type: 'error'` and `key: 'season_create_error_min_max_players'`, including `minPlayers` and `maxPlayers` in the `data` payload. The command handler in `src/commands/chat/new-command.ts` has been refactored to remove explicit validation logic from the `execute` method, delegating this responsibility to the service. The handler now checks for the specific error key and formats an appropriate error message for the user using the values from the instruction's data payload. This change successfully centralizes business logic and validation within the service layer, improving maintainability and separation of concerns.\n</info added on 2025-05-13T15:36:02.037Z>",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement Structured Error Handling",
          "description": "Introduce structured error handling in the /new season command, leveraging Prisma error types and custom error classes as needed.",
          "dependencies": [
            2
          ],
          "details": "Use instanceof checks for Prisma errors and handle them appropriately. Map errors to user-friendly messages or error codes, and ensure all exceptions are caught and logged according to project standards.\n<info added on 2025-05-13T15:38:54.523Z>\nUse instanceof checks for Prisma errors and handle them appropriately. Map errors to user-friendly messages or error codes, and ensure all exceptions are caught and logged according to project standards.\n\n<update timestamp=\"2025-05-13T15:38:48Z\">\nThe current implementation in `SeasonService.createSeason` already leverages Prisma's structured error handling by using `instanceof PrismaClientKnownRequestError` and checking specific error codes (e.g., `P2002` for unique constraint violations). Errors are mapped to `MessageInstruction` objects with distinct error keys, which are then processed by the `/new season` command handler (`new-command.ts`). This handler uses an `if/else if` chain to display appropriate user-facing messages based on the error key. The existing pattern is robust and aligns with best practices for Prisma error handling, including catching and logging all exceptions. No new custom error classes are required for this flow, as the `MessageInstruction` contract sufficiently structures error communication between the service and command handler. Logging is currently basic (`console.error`), but can be enhanced if project-wide standards evolve. The primary action for this subtask is to review and confirm the sufficiency of the current error handling structure, ensuring all Prisma and application-specific errors are properly caught, mapped, and logged.\n</update>\n</info added on 2025-05-13T15:38:54.523Z>\n<info added on 2025-05-13T15:39:24.455Z>\nUse instanceof checks for Prisma errors and handle them appropriately. Map errors to user-friendly messages or error codes, and ensure all exceptions are caught and logged according to project standards.\n<info added on 2025-05-13T15:38:54.523Z>\nUse instanceof checks for Prisma errors and handle them appropriately. Map errors to user-friendly messages or error codes, and ensure all exceptions are caught and logged according to project standards.\n\n<update timestamp=\"2025-05-13T15:38:48Z\">\nThe current implementation in `SeasonService.createSeason` already leverages Prisma's structured error handling by using `instanceof PrismaClientKnownRequestError` and checking specific error codes (e.g., `P2002` for unique constraint violations). Errors are mapped to `MessageInstruction` objects with distinct error keys, which are then processed by the `/new season` command handler (`new-command.ts`). This handler uses an `if/else if` chain to display appropriate user-facing messages based on the error key. The existing pattern is robust and aligns with best practices for Prisma error handling, including catching and logging all exceptions. No new custom error classes are required for this flow, as the `MessageInstruction` contract sufficiently structures error communication between the service and command handler. Logging is currently basic (`console.error`), but can be enhanced if project-wide standards evolve. The primary action for this subtask is to review and confirm the sufficiency of the current error handling structure, ensuring all Prisma and application-specific errors are properly caught, mapped, and logged.\n</update>\n\n<update timestamp=\"2025-05-13T15:39:16Z\">\nReview and confirmation completed. The error handling in `SeasonService.createSeason` is structured and robust, utilizing `instanceof` checks for Prisma errors and mapping specific error codes (e.g., `P2002`) to distinct `MessageInstruction` keys. Application-specific validation errors are similarly mapped. The command handler (`new-command.ts`) processes all documented error keys, providing user-friendly messages for each, with a default fallback for unexpected errors. All exceptions are caught and logged. The current implementation fulfills the requirements for structured error handling, and no further code changes are required for this subtask. Logging can be enhanced in future iterations as project standards evolve.\n</update>\n</info added on 2025-05-13T15:39:24.455Z>",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Integrate Message Generation Layer",
          "description": "Refactor the command to use the message generation layer for all user-facing responses, ensuring consistency and maintainability.",
          "dependencies": [
            3
          ],
          "details": "Replace inline or hardcoded messages with calls to the message generation layer. Ensure that all success, error, and informational messages are generated through this layer and support localization or formatting as required.\n<info added on 2025-05-13T17:18:17.215Z>\n<update timestamp=\"2025-05-13T17:18:09Z\">\nTo integrate the message generation layer in the `/new season` command handler, all user-facing messages must be generated via the `Lang` service, using structured `MessageInstruction` objects returned by `SeasonService`. This ensures consistency, maintainability, and support for localization and formatting.\n\n**Key Steps:**\n- **Import the Lang Service:** Add the necessary import for the `Lang` service at the top of `src/commands/chat/new-command.ts`.\n- **Define Language Keys:** Create or update language file entries for all message types, including success, error, and informational messages, with appropriate placeholders (e.g., `{seasonName}`, `{seasonId}`, `{discordUserId}`, etc.).\n- **Refactor Message Logic:** Replace all inline or hardcoded message strings with calls to `Lang.get(key, data)`, passing the relevant key and data object for placeholders. For service errors, use the `instruction.key` from `SeasonService` (or map it to the correct language key if needed). For critical and unknown subcommand errors, use the appropriate common keys.\n- **Verify MessageInstruction Structure:** Ensure that `SeasonService.createSeason()` returns a `MessageInstruction` with a `key` suitable for use as a language key (or easily mappable) and a `data` object containing all required placeholders.\n- **Test Localization and Formatting:** Validate that all messages are correctly generated, formatted, and localized according to the user's language settings.\n\n**Assumptions:**\n- The `LangService.js` exists and provides a `get(key, data)` method.\n- Language files (e.g., `lang.en-US.json`) are set up and can be extended with new keys.\n- `SeasonService.createSeason()` returns a `MessageInstruction` with a usable `key` and complete `data` object.\n</update>\n</info added on 2025-05-13T17:18:17.215Z>\n<info added on 2025-05-13T17:27:12.696Z>\nReplace inline or hardcoded messages with calls to the message generation layer. Ensure that all success, error, and informational messages are generated through this layer and support localization or formatting as required.\n<info added on 2025-05-13T17:18:17.215Z>\n<update timestamp=\"2025-05-13T17:18:09Z\">\nTo integrate the message generation layer in the `/new season` command handler, all user-facing messages must be generated via the `Lang` service, using structured `MessageInstruction` objects returned by `SeasonService`. This ensures consistency, maintainability, and support for localization and formatting.\n\n**Key Steps:**\n- **Import the Lang Service:** Add the necessary import for the `Lang` service at the top of `src/commands/chat/new-command.ts`.\n- **Define Language Keys:** Create or update language file entries for all message types, including success, error, and informational messages, with appropriate placeholders (e.g., `{seasonName}`, `{seasonId}`, `{discordUserId}`, etc.).\n- **Refactor Message Logic:** Replace all inline or hardcoded message strings with calls to `Lang.get(key, data)`, passing the relevant key and data object for placeholders. For service errors, use the `instruction.key` from `SeasonService` (or map it to the correct language key if needed). For critical and unknown subcommand errors, use the appropriate common keys.\n- **Verify MessageInstruction Structure:** Ensure that `SeasonService.createSeason()` returns a `MessageInstruction` with a `key` suitable for use as a language key (or easily mappable) and a `data` object containing all required placeholders.\n- **Test Localization and Formatting:** Validate that all messages are correctly generated, formatted, and localized according to the user's language settings.\n\n**Assumptions:**\n- The `LangService.js` exists and provides a `get(key, data)` method.\n- Language files (e.g., `lang.en-US.json`) are set up and can be extended with new keys.\n- `SeasonService.createSeason()` returns a `MessageInstruction` with a usable `key` and complete `data` object.\n</update>\n<info added on 2025-05-13T17:18:17.215Z>\n<update timestamp=\"2025-05-13T17:18:09Z\">\n**Implementation Update:**\n- **Imports Corrected:** Updated the import statement for the Lang service from `LangService.js` to `lang.js` (`import { Lang } from '../../services/lang.js';`). Added import for the `Language` enum helper (`import { Language } from '../../models/enum-helpers/language.js';`).\n- **Lang Method Updated:** All message generation calls now use `Lang.getRef(key, langCode, data)`, with `Language.Default` as the default language code. This sets the foundation for future localization using the user's locale.\n- **Language Keys Organized:** Added new hierarchical language keys in `lang/lang.en-US.json` under `refs.newCommand` and `refs.common.error` for improved maintainability. Example keys include `newCommand.season.create_success_channel`, `newCommand.season.error_name_taken`, and `common.error.critical_command`.\n- **Command Handler Refactored:** The `/new season` command handler in `src/commands/chat/new-command.ts` now exclusively uses the Lang service for all user-facing messages, including success, DM, error, and fallback messages. All hardcoded strings have been removed and replaced with calls to `Lang.getRef(...)`.\n- **Testing:** All messages are now generated, formatted, and localized according to the user's language settings, with support for dynamic placeholders and future locale-based rendering.\n</update>\n</info added on 2025-05-13T17:27:12.696Z>",
          "status": "done"
        }
      ]
    },
    {
      "id": 30,
      "title": "Modify SeasonService.createSeason for Message Instructions",
      "description": "Update `SeasonService.createSeason` to return structured message instruction objects for both success and error outcomes, facilitating user feedback via the Lang service.\n\nArchitectural Principle: Services should be designed to be chat platform-independent. Core logic should be abstracted from platform-specific APIs. The use of `MessageInstruction` objects is a key part of this principle.",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "Modify the `SeasonService.createSeason` method to return a structured object representing a message instruction, rather than the created season object or throwing raw errors. Define a standard interface or type for `MessageInstruction` (e.g., `{ type: 'success' | 'error', key: string, data?: Record<string, any> }`) that can be used across services. On successful season creation, return a success instruction object including relevant season details (like ID and name) for the message. On failure (e.g., validation errors, database issues), catch the error and return an error instruction object with an appropriate message key and relevant error data. Ensure all potential error paths within `createSeason` are handled by returning an error instruction.",
      "testStrategy": "Write unit tests for `SeasonService.createSeason`. Test the successful creation path, verifying that the method returns a success `MessageInstruction` object with the correct `type`, a specific success `key` (e.g., 'season_created_success'), and that the `data` property contains expected details of the created season (e.g., `id`, `name`). Test various failure paths, including invalid input data (e.g., missing name, invalid format) and simulated internal errors (e.g., database write failure), verifying that the method returns an error `MessageInstruction` object with `type: 'error'`, an appropriate error `key` (e.g., 'validation_error', 'database_error'), and relevant error details in the `data` property. Ensure that the method does not throw exceptions directly for handled errors.",
      "subtasks": []
    },
    {
      "id": 31,
      "title": "Refactor /new season Command to Use Lang Service",
      "description": "Refactor the '/new season' subcommand handler in src/commands/chat/new-command.ts to utilize the Lang service for all user-facing messages based on structured instructions from SeasonService.",
      "details": "This task involves modifying the `/new season` command handler located in `src/commands/chat/new-command.ts`. The primary goal is to eliminate direct string construction of user feedback messages (replies, follow-ups, DMs, errors) and instead rely entirely on the `Lang` service (`Lang.getRef`, `Lang.getEmbed`).\n\nSteps:\n1.  Identify all points in the `/new season` command handler where user feedback messages are currently constructed and sent.\n2.  Ensure that the command handler calls the updated `SeasonService.createSeason` (as per Task 30), which now returns structured message instruction objects.\n3.  For each message instruction received from `SeasonService`, use the `Lang` service (e.g., `Lang.getRef(instruction.key, instruction.placeholders)`) to generate the final message content or embed.\n4.  Send the message content/embed returned by the `Lang` service to the user via the appropriate interaction response method (reply, followUp, etc.). Handle potential DM messages separately if required by the instructions.\n5.  Define new language keys and corresponding entries in the language files (e.g., `lang.en-US.json`, `lang.fr-FR.json`, etc.) for all messages previously hardcoded or constructed via string concatenation in the command handler. These entries should include placeholders for dynamic data (e.g., season name, ID, dates, error details).\n6.  Remove all instances of direct string message construction or concatenation intended for user output within the command handler.\n7.  Verify that the command handler does *not* instantiate `PrismaClient` directly. It should rely on the `SeasonService` to handle database interactions, assuming `SeasonService` uses a shared/singleton `PrismaClient` instance (as may be addressed in a separate preliminary task).",
      "testStrategy": "Thoroughly test the refactored `/new season` command in a development environment.\n\nTest Cases:\n1.  **Successful Season Creation:** Execute the command with valid parameters. Verify that the success message displayed to the user (reply or embed) is correctly formatted, includes the expected dynamic data (season name, ID, dates), and originates from the `Lang` service (visually inspect the content and confirm it matches the language file entry with placeholders filled).\n2.  **Validation Errors:** Execute the command with invalid parameters that should trigger validation errors within `SeasonService` (e.g., invalid dates, missing name, name too long). Verify that the error messages displayed are correct, informative, and originate from the `Lang` service, with appropriate placeholders filled (e.g., detailing the specific validation failure).\n3.  **Service Interaction Errors:** Simulate or trigger other potential errors during the `SeasonService.createSeason` call (e.g., database error, unexpected logic error). Verify that the command handler catches these errors and uses the `Lang` service to provide a user-friendly error message.\n4.  **Placeholder Verification:** For each message type (success, various errors), ensure that all intended placeholders (e.g., `{seasonName}`, `{seasonId}`, `{errorDetail}`) are correctly replaced with actual data in the final message output.\n5.  **Code Inspection:** Review the `src/commands/chat/new-command.ts` file to confirm that no direct string concatenation or hardcoded message strings intended for user output remain. Also, confirm that `PrismaClient` is not instantiated within this file.\n6.  **Language File Verification:** Check the language files (`lang.*.json`) to ensure that new keys for `/new season` messages have been added and are correctly structured with placeholders.",
      "status": "pending",
      "dependencies": [
        30
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 32,
      "title": "Implement Tests for /new season Command",
      "description": "Create comprehensive integration tests focusing on database interaction (as per TECHNICAL_ARCHITECTURE.md) and unit tests for the logic layer for the /new season command, covering SeasonService.createSeason and related logic, including success and various error scenarios.",
      "status": "pending",
      "dependencies": [
        30,
        31
      ],
      "priority": "high",
      "details": "Implement integration tests for `SeasonService.createSeason` focusing on interactions with the database. These tests should verify successful season creation, handling of duplicate season names, and cases where the creator ID might not exist. Ensure these tests assert that the service returns the correct `MessageInstruction` objects as implemented in Task 30. Additionally, write unit tests for any pure logic functions used by the `/new season` command handler or `SeasonService.createSeason` that are suitable for isolation. The tests should cover edge cases and invalid inputs where applicable. Leverage the test database setup for integration tests. This test structure, including database integration tests and logic layer unit tests, aligns with the requirements outlined in TECHNICAL_ARCHITECTURE.md. Ensure tests are well-structured and easy to understand.",
      "testStrategy": "Run all newly created integration and unit tests using the standard test runner. Verify that all tests pass for successful creation, duplicate name errors, creator not found errors, and any other implemented error conditions. Check test coverage metrics to ensure adequate coverage of the `SeasonService.createSeason` function and the relevant parts of the `/new season` command handler and associated logic. Manually test the `/new season` command in a development environment to confirm that the user feedback via the Lang service (implemented in Task 31) correctly reflects the outcomes tested by the automated tests.",
      "subtasks": []
    },
    {
      "id": 33,
      "title": "Refactor Language Keys for joinCommand to Use Constants",
      "description": "To improve type safety and prevent mismatches between language keys used in code and those defined in language files, this task will establish a scalable pattern for using predefined constants for *all* command-related language strings. The initial implementation will focus on refactoring the `joinCommand` usage as an example. Additionally, a startup check will be implemented to proactively verify that all commands have corresponding language key entries defined.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "details": "The goal is to create a central place for language key constants (e.g., `lang-keys.ts`) structured to support keys for every command. This file should use `as const` for type safety. The refactor will involve defining a clear structure within this file (e.g., a top-level `Commands` object with nested objects for each command like `JoinCommand`) and then updating the `joinCommand` related code (SeasonService, joinSeason command) to use these new constants.\n\nFurthermore, a critical startup check must be implemented. This check will iterate through all registered commands and verify that each command has a corresponding entry (e.g., `LangKeys.Commands.YourCommandName`) defined in the `lang-keys.ts` structure. If any command is missing its language key definition, the application should fail fast during startup with a clear error message, preventing runtime errors related to missing language keys.",
      "testStrategy": "Manually test the `/join season` command with various scenarios (success, already joined, season not found) to ensure messages are displayed correctly using the new constants. Verify that the structure created in `lang-keys.ts` is logical and easily extensible for other commands.\n\nTest the new startup check:\n1. Ensure the application starts successfully when all commands have corresponding entries in `LangKeys.Commands`.\n2. Temporarily remove or comment out the entry for a command (e.g., `JoinCommand`) in `lang-keys.ts` and verify that the application fails to start with a clear error message indicating the missing entry.\n3. Verify the check runs automatically as part of the application's initialization process.\n\nEnsure the project compiles without TypeScript errors.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create lang-keys.ts and Define Structure for All Command Keys",
          "description": "Create a new file (e.g., src/constants/lang-keys.ts). Define an exported object (e.g., LangKeys) using `as const`. Structure this object to contain nested objects or namespaces for different categories of language keys, starting with a top-level object for 'Commands'. Inside 'Commands', create a nested object for 'JoinCommand' containing all full string paths for language keys related to the join command (e.g., refs.joinCommand.join_season_success). The structure under `LangKeys.Commands` should be designed such that each command can have its own dedicated nested object.",
          "details": "Ensure all keys currently used in SeasonService.ts for addPlayerToSeason and potentially in joinSeason.ts command are covered under LangKeys.Commands.JoinCommand. The structure under `LangKeys.Commands` must be suitable for the planned startup check to iterate and verify coverage for *all* commands.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 33
        },
        {
          "id": 2,
          "title": "Update SeasonService.ts to Use LangKeys.Commands.JoinCommand Constants",
          "description": "Modify src/services/SeasonService.ts. Import the LangKeys object. In the addPlayerToSeason method, replace all hardcoded string literals for language keys with references to the constants defined in LangKeys.Commands.JoinCommand.",
          "details": "Example: Change return { type: 'error', key: 'refs.joinCommand.join_season_error_already_joined', ... }; to return { type: 'error', key: LangKeys.Commands.JoinCommand.ErrorAlreadyJoined, ... };",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 33
        },
        {
          "id": 3,
          "title": "Update joinSeason.ts Command to Use LangKeys.Commands.JoinCommand (If Applicable)",
          "description": "Review src/commands/chat/joinSeason.ts. If it directly constructs or uses any language keys for Lang.getRef that are part of joinCommand, update these to use constants from LangKeys.Commands.JoinCommand.",
          "details": "Currently, it seems to primarily use keys from SeasonService's response, so this subtask might be a quick verification. Ensure the LangKeys.Commands.JoinCommand structure is used.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 33
        },
        {
          "id": 5,
          "title": "Implement Language Key Coverage Check Logic",
          "description": "Create a utility function or module responsible for verifying that every registered command has a corresponding entry within the `LangKeys.Commands` structure defined in `lang-keys.ts`. This check should compare the list of known, registered commands against the keys present directly under `LangKeys.Commands`.",
          "details": "The logic should iterate through the list of commands available to the application and check if a key matching the command's identifier (or a derived identifier) exists as a property of `LangKeys.Commands`. If a command is found without a corresponding entry, the check should identify it.",
          "status": "done",
          "dependencies": [
            1
          ],
          "parentTaskId": 33
        },
        {
          "id": 6,
          "title": "Integrate Language Key Coverage Check into Application Startup",
          "description": "Modify the application's main entry point or initialization sequence to execute the language key coverage check (implemented in Subtask 5) early in the startup process, after commands have been loaded but before the application is fully operational.",
          "details": "Ensure that if the check fails (i.e., finds missing command language key entries), the application terminates immediately with a descriptive error message indicating which command(s) are missing language key definitions. This should be a critical failure.",
          "status": "done",
          "dependencies": [
            5
          ],
          "parentTaskId": 33
        },
        {
          "id": 4,
          "title": "Testing and Verification (joinCommand LangKeys Refactor & Startup Check)",
          "description": "After implementing the refactor and the startup check, perform comprehensive testing. This includes manually testing the `/join season` command with various scenarios to ensure messages are correct, verifying the structure in `lang-keys.ts` is extensible, and thoroughly testing the new startup check's behavior.",
          "details": "This is a manual testing step. Test the `/join season` command (success, already joined, season not found). Verify the `LangKeys.Commands` structure is logical. Crucially, test the startup check by running the application with all entries present (should succeed) and then with a command's entry temporarily removed (should fail fast with a clear error). Ensure the project compiles without TypeScript errors.",
          "status": "pending",
          "dependencies": [
            2,
            3,
            6
          ],
          "parentTaskId": 33
        },
        {
          "id": 7,
          "title": "Add placeholder LangKeys.Commands objects for all commands flagged by the coverage check",
          "description": "For each command flagged as missing by the language key coverage check (Dev, Help, Info, JoinSeason, New, Test), add a corresponding empty object to LangKeys.Commands in lang-keys.ts. This ensures the coverage check passes and provides a place to add language keys as each command is refactored.",
          "details": "Update src/constants/lang-keys.ts to include empty objects for Dev, Help, Info, JoinSeason, New, and Test under LangKeys.Commands. Example: LangKeys.Commands.Dev = {}. This is a preparatory step for future refactors.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 33
        }
      ]
    }
  ]
}